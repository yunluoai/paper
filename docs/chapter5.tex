\chapter{实验结果与性能分析}


%*********************************************************************
% 5.1 全局指令选择正确性验证
%*********************************************************************
\section{全局指令选择正确性验证}
本节通过一组具有代表性的LLVM IR示例程序，对DSP架构下的基于GlobalISel框架的代码生成流程进行正确性验证。验证重点覆盖LLVM IR向GMIR的转换、指令合法化、寄存器组选择以及机器指令选择这四个主要阶段。通过对关键Pass阶段的中间结果进行对比分析，系统性地验证全局指令选择流程在DSP后端中的功能正确性与稳定性。


% 5.1.1 基本指令正确性验证
\subsection{基本指令正确性验证}
本节旨在验证DSP后端基本指令的正确性，重点关注算术运算指令与内存访问指令的指令选择结果。为此，本文构造了一个综合示例一，该示例同时包含函数参数传递、内存读写操作以及整数加法与乘法运算等典型计算模式，能够覆盖DSP后端中最常见的指令选择路径。

\par

由于LLVM IR具有良好的目标无关性，且从C语言到LLVM IR的转换过程并非本文关注重点，本文在分析过程中省略前端生成IR的具体细节，直接展示从LLVM IR到目标机器码的转换流程，以突出指令选择与后端代码生成阶段的行为特征。

1.LLVM IR输入

示例一的LLVM IR如下所示（已去除调试信息）：

\lstset{language=c++}
\begin{lstlisting}
define dso_local i32 @testArith(i32 noundef %a, i32 noundef %b) {
	entry:
	%a.addr = alloca i32
	%b.addr = alloca i32
	store i32 %a, ptr %a.addr
	store i32 %b, ptr %b.addr
	%0 = load i32, ptr %a.addr
	%1 = load i32, ptr %b.addr
	%add = add i32 %0, %1
	%2 = load i32, ptr %a.addr
	%mul = mul i32 %add, %2
	ret i32 %mul
}
\end{lstlisting}

2.GMIR生成阶段

如图\ref{fig:case_1_gmir_gen_dump}所示，在GMIR生成阶段，LLVM IR被转换为与目标架构无关的GMIR。从IR Dump的结果可以观察到：

\begin{itemize}
	\item
	add与mul指令分别被映射为G\_ADD与G\_MUL；
	
	\item
	load与store被转换为G\_LOAD与G\_STORE；
	
	\item 
	函数参数通过COPY指令从物理寄存器拷贝到虚拟寄存器。
	
\end{itemize}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_1_gmir_gen_dump.png}
	\caption{示例一GMIR生成阶段Dump图}
	\label{fig:case_1_gmir_gen_dump}
\end{figure}

该结果表明，LLVM IR到GMIR的转换过程保持了原有运算语义与数据依赖关系，为后续后端处理提供了正确的输入。

3.合法化阶段

合法化阶段的主要任务是将GMIR中不被目标架构直接支持的指令形式，转换为目标架构可处理的合法形式。由于32bit的G\_ADD、G\_MUL、G\_LOAD和G\_STORE指令在DSP架构下均为合法操作，于是示例中并未触发类型扩展、分裂或指令拆分等复杂合法化操作。如图\ref{fig:case_1_legalize_dump}所示，合法化前后指令结构保持一致，说明DSP的合法化规则能够正确覆盖基本算术与内存访问指令。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_1_legalize_dump.png}
	\caption{示例一合法化阶段Dump图}
	\label{fig:case_1_legalize_dump}
\end{figure}

4.寄存器组选择阶段

在寄存器组选择阶段，编译器为每个虚拟寄存器分配合适的寄存器组。在DSP后端中，参与整数算术运算的虚拟寄存器统一映射至通用整数寄存器组GPRB。如图\ref{fig:case_1_regbank_select_dump}所示，从寄存器组选择后的Dump结果可以观察到，所有算术指令的操作数及结果均被分配到GPRB寄存器组，且寄存器类型与操作数位宽保持一致。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_1_regbank_select_dump.png}
	\caption{示例一寄存器组选择阶段Dump图}
	\label{fig:case_1_regbank_select_dump}
\end{figure}

该结果表明所有参与算术运算的虚拟寄存器均被正确分配至通用寄存器组，同时未引入额外的跨寄存器组数据复制或冗余中间指令。

5.机器指令选择阶段

在机器指令选择阶段，GMIR被转换为DSP架构的目标机器指令。如\ref{fig:case_1_instr_select_dump}所示，从Dump结果可以观察到所有中间指令（除COPY外，需要在后续Pass中单独处理）都被正确的映射到DSP后端机器指令。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_1_instr_select_dump.png}
	\caption{示例一机器指令选择阶段Dump图}
	\label{fig:case_1_instr_select_dump}
\end{figure}

6.最终代码生成

在经过寄存器分配、指令调度等后续后端Pass处理后，最终生成合法且可执行的DSP机器码。如图\ref{fig:case_1_final_dump}所示，整体代码生成流程未出现语义偏差或异常，验证了基本指令在GlobalISel框架下的端到端正确性。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_1_final_dump.png}
	\caption{示例一最后阶段Dump图}
	\label{fig:case_1_final_dump}
\end{figure}


% 5.1.2 控制流指令正确性验证
\subsection{控制流指令正确性验证}
除基本算术与内存访问指令这些基本指令外，控制流指令的正确生成和映射同样是验证编译器后端正确性的重要体现。本节针对对控制流相关指令的处理过程进行验证，重点覆盖比较与条件分支、循环结构以及函数调用三类典型控制流场景。

\par

1.比较+分支+跳转指令

比较与条件分支是程序控制流构建的基础。在LLVM IR中，该类操作通常通过icmp与br指令组合表达；在GlobalISel框架下，则对应为G\_ICMP与G\_BRCOND等GMIR指令。为验证DSP后端对该类控制流指令的处理正确性，本文构建了一个同时包含比较、条件分支及无条件跳转的示例二，其LLVM IR如下所示：

\lstset{language=c++}
\begin{lstlisting}
define dso_local i32 @testBranch() {
	entry:
	%retval = alloca i32
	%a = alloca i32
	%b = alloca i32
	store i32 10, ptr %a
	store i32 20, ptr %b
	%0 = load i32, ptr %a
	%1 = load i32, ptr %b
	%cmp = icmp slt i32 %0, %1
	br i1 %cmp, label %if.then, label %if.else
	
	if.then:
	store i32 0, ptr %retval
	br label %return
	
	if.else:
	store i32 1, ptr %retval
	br label %return
	
	return:  %2 = load i32, ptr %retval
	ret i32 %2
}
\end{lstlisting}

针对该示例，在GlobalISel各关键阶段中的处理过程如下：

\begin{itemize}
	\item
	在GMIR生成阶段，LLVM IR中的比较指令被正确转换为G\_ICMP，其比较谓词与操作数保持一致；条件跳转指令被转换为G\_BRCOND，并以比较结果作为分支条件。
	
	\item
	在合法化阶段，由于DSP架构支持整数比较操作，无需进一步拆分，相关指令保持原有结构。
	
	\item 
	在寄存器组选择阶段，编译器为比较操作及其结果所涉及的虚拟寄存器分配了合适的寄存器组，确保比较结果能够以符合DSP架构约定的方式参与后续控制流指令。
	
	\item 
	在机器指令选择阶段，G\_ICMP与后续的G\_BRCOND会被联合处理，映射为DSP架构下的比较指令与条件跳转指令，比较结果通过条件码寄存器传递，从而完成分支控制。
	
\end{itemize}

如图\ref{fig:case_2_final_dump}所示，在函数入口基本块中，比较指令首先生成条件码寄存器状态，随后通过条件跳转指令根据比较结果在两个后继基本块之间进行分支选择，验证了比较与条件分支指令的正确映射。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_2_final_dump.png}
	\caption{示例二入口基本块最后阶段Dump图}
	\label{fig:case_2_final_dump}
\end{figure}

如图\ref{fig:case_2_final_dump_2}所示，条件分支后的if.then与if.else基本块分别执行对应路径逻辑，并通过无条件跳转汇合至统一的返回基本块。最终生成的机器码中，各分支路径与返回块之间的控制流关系与LLVM IR描述保持一致。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_2_final_dump_2.png}
	\caption{示例二条件分支基本块最后阶段Dump图}
	\label{fig:case_2_final_dump_2}
\end{figure}

实验结果表明，从LLVM IR到最终机器码的转换过程中，比较条件与分支目标均保持一致，程序控制流未发生偏移或错误跳转，验证了比较与分支指令选择的正确性。

\par

2.循环指令

循环结构通常由条件判断、分支跳转以及回边构成，是控制流指令组合应用的典型场景。在LLVM IR中，循环通过多个基本块以及br指令共同表示；在GMIR层面，该多基本块结构及其控制流关系被完整保留下来，为后端代码生成提供了清晰的控制流语义。

\par

为验证DSP后端对循环指令的处理正确性，本文构建了一个包含循环指令的示例三，其LLVM IR如下所示：

\lstset{language=c++}
\begin{lstlisting}
define dso_local i32 @testLoop() {
	entry:
	%i = alloca i32
	store i32 0, ptr %i
	br label %for.cond
	
	for.cond:
	%0 = load i32, ptr %i
	%cmp = icmp slt i32 %0, 10
	br i1 %cmp, label %for.body, label %for.end
	
	for.body:
	br label %for.inc, !dbg !21
	
	for.inc:
	%1 = load i32, ptr %i
	%inc = add nsw i32 %1, 1
	store i32 %inc, ptr %i
	br label %for.cond
	
	for.end:
	ret i32 0
}
\end{lstlisting}

针对该示例，在GlobalISel各关键阶段中的处理过程如下：

\begin{itemize}
	\item
	在GMIR生成阶段，各基本块及其控制流关系被准确映射为MBB，循环条件与跳转关系通过G\_BR与G\_BRCOND指令表达。
	
	\item
	在合法化阶段，合法化前后指令结构保持一致，表明DSP后端的合法化规则能够覆盖该类循环场景的基本操作需求。
	
	\item 
	在寄存器组选择阶段，循环体内的算术与内存操作被正确映射至DSP通用寄存器组，循环条件判断所依赖的比较结果亦能够被正确传播。
	
	\item 
	在机器指令选择阶段，循环控制流相关的G\_ICMP与G\_BRCOND被联合分析并映射为DSP架构下的比较指令与条件跳转指令：比较结果通过条件码寄存器生成，并由条件跳转指令读取实现分支决策。
	
\end{itemize}

如图\ref{fig:case_3_final_dump}所示，在循环条件基本块中，编译器首先对循环变量与上界进行比较，并通过条件码寄存器生成分支条件，随后依据比较结果在循环体与循环结束块之间进行跳转，验证了循环条件判断与分支决策逻辑的正确性。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_3_final_dump.png}
	\caption{示例三循环条件基本块最后阶段Dump图}
	\label{fig:case_3_final_dump}
\end{figure}


如图\ref{fig:case_3_final_dump_2}所示，循环体与自增基本块在执行完成后通过无条件跳转形成回边，并重新进入条件判断块；当循环条件不满足时，控制流正确跳转至循环结束块并完成函数返回，表明循环控制流在后端生成过程中保持一致。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_3_final_dump_2.png}
	\caption{示例三循环体基本块最后阶段Dump图}
	\label{fig:case_3_final_dump_2}
\end{figure}


从最终生成的机器码可以观察到，循环入口、循环体以及循环回边对应的跳转指令均与原始LLVM IR的控制流结构保持一致，且不存在多余或缺失的跳转指令。这表明GlobalISel在DSP后端中能够正确处理多基本块循环结构，确保循环语义的正确性。

\par

3.函数调用指令

函数调用是另一类重要的控制流操作，其正确性依赖于调用约定、参数传递以及返回值处理等多个方面。在LLVM IR中，函数调用通过call指令表示；在GlobalISel框架下，该过程涉及CallLowering与指令选择等多个阶段。

\par

为验证DSP后端在GlobalISel框架下对函数调用指令的处理正确性，构造了一个简单的示例四，其中main函数调用前文定义的testBranch函数，其LLVM IR如下所示：

针对该示例函数，函数调用在各阶段的处理过程如下：

\begin{itemize}
	\item
	在GMIR生成阶段，call指令被转换为一系列与调用约定相关的GMIR指令，包括参数准备、调用指令以及返回值接收等操作。
	
	\item
	在合法化阶段，合法化前后指令结构保持一致，表明DSP后端的合法化规则能够覆盖该类函数调用场景的基本操作需求。
	
	\item 
	在寄存器组选择阶段，函数参数与返回值被分配至DSP架构规定的寄存器或栈位置，符合DSP ABI的约定规则。
	
	\item 
	在机器指令选择阶段，调用相关的GMIR指令被映射为DSP架构支持的跳转与返回指令，并正确维护返回地址与调用现场。最终生成的机器码中，函数调用前后的寄存器状态与栈帧布局保持一致，函数返回值能够被正确读取并参与后续计算。
	
\end{itemize}

如图\ref{fig:case_4_final_dump}所示，实验结果表明DSP后端在GlobalISel框架下能够正确完成函数调用相关控制流的指令选择，保证跨函数控制流的正确传递。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_4_final_dump.png}
	\caption{示例四最后阶段Dump图}
	\label{fig:case_4_final_dump}
\end{figure}


%*********************************************************************
% 5.2 全局指令选择性能分析
%*********************************************************************
\section{全局指令选择性能分析}
本章主要针对编译时间、代码大小以及执行周期三个方面来对基于DAG的指令选择、未优化的全局指令选择以及优化的全局指令选择来进行对比。


% 5.2.1 编译时间
\subsection{编译时间}
编译时间是衡量编译器工程可用性与开发效率的重要指标之一，尤其在编译器持续迭代与频繁回归验证的场景下，后端编译开销的变化将直接影响开发效率与测试周期。因此，本节围绕编译时间这一维度，对不同指令选择方案在DSP后端中的表现进行系统对比分析。

1.度量方法与相关指标说明

本文的编译时间的量化分析基于Clang自带的编译时间追踪机制，该机制能够对编译过程中各阶段的执行时间进行精细化统计，从而为分析编译器性能瓶颈与优化效果提供可靠的数据支撑。图\ref{fig:compile_time_example}中展示了部分关键时间指标及其在不同编译阶段的分布情况。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/compile_time_example.png}
	\caption{不同编译阶段时间指标图}
	\label{fig:compile_time_example}
\end{figure}

其中，各时间指标的含义如下：

\begin{itemize}
	\item
	User Time（用户态时间）：表示CPU在用户态执行编译器自身代码所消耗的时间，仅反映编译器逻辑计算的开销，不包含操作系统内核相关操作。
	
	\item
	System Time（系统态时间）：表示CPU在内核态执行系统调用（如文件读写、内存管理、进程调度等）所消耗的时间，属于编译过程中的系统辅助开销。
	
	\item 
	User+System Time（用户态加系统态时间）：反映CPU在该阶段用于计算的总耗时，是用户态和系统态时间的累加，但不包含I/O等待和CPU空闲时间。
	
	\item 
	Wall Time（壁钟时间）：指从编译阶段开始到结束所经历的实际物理时间，包含CPU计算、I/O等待、进程调度以及资源竞争等所有因素。在真实工程场景中，该指标最能直观反映用户实际感知到的编译等待时长，因此也是本文关注的核心量化指标。
	
\end{itemize}

LLVM编译流程可粗略划分为以下几个阶段：

\begin{itemize}
	\item
	Front end（前端）：包括源代码解析、语法分析、语义分析等操作，主要负责将高级语言代码转换为中间表示。
	
	\item
	LLVM IR generation（LLVM IR生成）：将前端分析结果转换为LLVM中间表示，为后续优化和代码生成奠定基础。
	
	\item 
	Optimizer（优化器）：对LLVM IR进行多级优化，包括控制流优化、数据流优化及目标无关优化等。
	
	\item 
	Machine code generation（机器码生成）：编译器后端的核心阶段，负责指令选择、寄存器分配、指令调度以及最终目标机器码的生成。
	
\end{itemize}

由于指令选择阶段在LLVM后端中与其他流程高度耦合，难以单独抽离并进行精确量化，因此本文在编译时间分析中，将关注点放在后端整体执行时间上。具体而言，仅统计Machine Code Generation阶段的Wall Time，以此作为后端编译开销的统一度量标准。该统计方式在保证分析结果可比性和稳定性的同时，能够有效反映后端相关优化对实际编译时间的影响，为后续性能评估提供依据。

2.实验设置与统计方法

实验基于Embench测试集进行。为降低单次测量中噪声与偶然因素对实验结果的影响，本文采用多次重复实验的统计方法：在相同实验环境与配置条件下，对每个测试样例分别执行10次编译；在结果统计阶段，剔除两个最大值和两个最小值，对剩余数据取平均值作为该样例在对应优化等级下的编译时间；随后，对Embench测试集中22个基准程序的结果进一步取平均，得到不同优化等级下的平均编译时间，用于不同指令选择方案之间的对比分析。

3.实验结果与分析

图\ref{fig:compile_time_contrast}给出了在Embench测试集上两种指令选择方案在不同优化等级下的平均编译时间对比结果。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/compile_time_contrast.png}
	\caption{两种指令选择方案平均编译时间对比图}
	\label{fig:compile_time_contrast}
\end{figure}

从图中可以观察到，在四个优化等级下，GlobalISel均表现出更低的平均编译时间。该趋势在O0与O1等低优化等级下尤为明显，表明在中端优化尚未充分展开的情况下，指令选择框架自身的设计差异已对后端编译效率产生显著影响。这一结果主要源于GlobalISel在指令选择阶段采用的基于规则匹配与直接构造Machine IR的流程，相较于传统基于DAG的指令选择方式，其构建与遍历成本更低，整体流程更为线性。此外，GlobalISel在GMIR层面引入的早期规范化与合并优化，也在一定程度上减少了后续Pass的处理负担，从而降低了整体后端编译开销。

4.实验结论

综合实验结果可以得出结论：在DSP后端中，GlobalISel相较于SelectionDAG在编译时间维度上具有稳定优势。该优势在不同优化等级下均保持一致，说明其并非依赖特定优化配置，而是来源于指令选择框架本身在流程设计与中间表示处理上的效率改进。这一特性使得GlobalISel更适合于需要频繁编译与快速迭代的工程场景，为后续编译器优化与性能验证提供了良好的基础。


% 5.2.2 代码尺寸
\subsection{代码尺寸}
代码尺寸是衡量编译器后端代码生成质量的重要指标之一，尤其在DSP等嵌入式场景中，程序存储空间受限，指令密度直接影响系统可部署规模与功耗水平。因此，分析不同指令选择方案对最终生成代码体积的影响，对于评估GlobalISel优化效果具有重要意义。

1.度量方法

本文的代码尺寸的量化基于llvm-size工具完成，并以目标文件中text段大小作为代码尺寸的度量指标。该指标能够直接反映指令选择与代码生成阶段所产生的指令数量与编码密度，同时有效规避调试信息、符号表等非执行内容对统计结果的干扰。

\par

2.实验设置与统计方法

在实验设置上，本文基于Embench测试集，对每个基准程序分别在四个优化等级下进行编译，并统计对应生成目标文件的text段大小。对于同一测试样例与优化等级，取单次编译结果作为该样例的代码尺寸；随后，对测试集内所有基准程序的结果取平均值，得到各优化等级下的平均代码段尺寸，用于不同指令选择方案之间的对比分析。


3.实验结果分析

图\ref{fig:size_contrast}给出了在Embench测试集上，未引入优化的GlobalISel与引入优化后的GlobalISel在不同优化等级下的平均代码段尺寸对比结果。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/size_contrast.png}
	\caption{优化前后平均代码段尺寸对比图}
	\label{fig:size_contrast}
\end{figure}

从整体趋势来看，在四个优化等级下，优化后的GlobalISel方案均生成了更小的平均代码体积，且这一优势在O0等级下尤为明显。这表明，即使在未启用高层LLVM IR优化的情况下，后端针对指令选择与指令组合所引入的优化措施，仍然能够有效减少冗余指令并提升代码密度。高优化等级下，代码尺寸下降幅度相对收敛。这一现象表明，在高层LLVM IR优化充分展开后，部分冗余已在前端或中端被消除，后端指令选择优化对代码体积的影响更多体现为精细化的指令密度改进，而非数量级上的减少。

4.实验结论

综合实验结果可以得出结论：相较于未优化的GlobalISel实现，引入针对DSP架构特点的指令选择与指令组合优化后，编译器在各优化等级下均能够生成更紧凑的目标代码。这表明所提出的优化策略不仅在性能层面有效，同时也在代码尺寸这一关键指标上取得了稳定收益，为后续嵌入式场景中的实际部署提供了有力支撑。结合前文第3章中对优化策略的分析，可以将代码体积下降的原因归纳为以下几个方面：

\begin{itemize}
	\item
	冗余通用指令的提前消除
	通过在合法化前与合法化后引入针对GMIR的合并优化，显著减少了由类型拆分、表达式规范化以及中间表示泛化所引入的冗余指令，从而降低了最终生成指令的数量。
	
	\item
	目标相关指令模式的更充分匹配
	优化后的GlobalISel在指令选择阶段能够更有效地将通用指令序列映射为DSP架构提供的复合指令或更紧凑的指令形式，减少了多条通用指令展开带来的代码膨胀。
	
	\item 
	立即数与内存操作的定制化优化
	针对立即数装载与小规模内存操作引入的目标相关优化，避免了不必要的长立即数装载序列及库函数调用，进一步降低了代码体积。
	
\end{itemize}


% 5.2.3 执行周期
\subsection{执行周期}
执行周期是衡量编译器后端优化效果最直接、也是最具代表性的性能指标之一，尤其对于DSP等以吞吐率和实时性为核心设计目标的处理器架构而言，程序执行周期的变化能够直观反映指令选择、寄存器分配以及指令调度等后端决策对实际运行性能的影响。因此，本节围绕执行周期这一维度，对不同指令选择方案在DSP平台上的运行表现进行对比分析。

1.度量方法

本文的执行周期测量基于DSP工具链配套的仿真器环境完成。在仿真环境中，仿真器能够在程序执行过程中精确统计指令发射与执行情况，并直接给出程序完成所消耗的总周期数。

\par

为保证不同指令选择方案在执行周期统计上的可比性，本文在测量过程中统一采用相同的测试程序、输入数据以及运行环境配置，并仅关注程序主体计算阶段的执行周期，避免初始化、调试输出等非核心逻辑对统计结果产生干扰。最终得到的执行周期能够较为真实地反映编译器后端生成代码在DSP架构上的运行效率。

2.实验设置与统计方法

执行周期实验同样基于Embench测试集进行。对于每个基准程序，在相同硬件平台和配置条件下分别运行多次，以降低偶然扰动对测量结果的影响。具体统计方法如下：对每个测试样例在对应优化等级下执行10次，剔除两个最大值和两个最小值，对剩余结果取平均值作为该样例的执行周期；随后，对测试集中全部基准程序的执行周期结果进一步取平均，得到不同优化等级下的平均执行周期，用于不同指令选择方案之间的对比分析。

\par

该统计方式能够有效平衡测量精度与实验成本，在保证数据稳定性的同时，避免个别异常运行结果对整体趋势判断产生干扰。

3.实验结果与分析

图\ref{fig:cycle_contrast}给出了在Embench测试集上，不同指令选择方案在各优化等级下的平均执行周期对比结果。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/cycle_contrast.png}
	\caption{不同指令选择方案平均执行周期对比图}
	\label{fig:cycle_contrast}
\end{figure}

从实验结果可以观察到，相较于未优化的GlobalISel实现，引入针对DSP架构的指令选择与指令组合优化后，程序在所有优化等级下的平均执行周期均呈现出下降趋势。这表明，在高层LLVM IR优化与后端优化协同作用的场景中，GlobalISel所引入的目标相关指令匹配、冗余指令消除以及寄存器组绑定优化，能够进一步挖掘DSP架构的指令级并行潜力，从而在整体执行效率上获得持续收益。

\par

结合第3章中对优化策略的分析，可以将执行周期下降的主要原因归纳为以下几个方面：一是冗余通用指令在合法化前后被提前消除，减少了无效计算与不必要的数据搬移；二是优化后的指令选择能够更充分地利用DSP架构提供的复合指令与并行执行能力，提高了单周期内的有效计算密度；三是寄存器组选择与条件码处理策略的优化，降低了跨寄存器组复制与条件值传递带来的额外开销，从而缩短了关键路径长度。

4.实验结论

综合实验结果可以得出结论：在DSP后端中，引入针对目标架构特性的GlobalISel优化后，编译器生成代码在执行周期维度上取得了稳定且可观的性能提升。该提升在不同优化等级下均具有一致性，说明其并非依赖特定编译配置，而是源于指令选择框架与目标相关优化策略在整体设计上的协同改进。这一结果进一步验证了前文提出的优化方法在实际运行性能上的有效性，为后续章节中更细粒度的性能分析与应用验证奠定了基础。


%*********************************************************************
% 5.3 测试评估平台功能展示
%*********************************************************************
\section{测试评估平台功能展示}
测试评估平台围绕编译器工具链的持续迭代需求进行设计，集成了性能数据采集、历史回归分析、版本对比以及汇编级诊断等功能。平台通过对不同Commit在统一测试集上的性能表现进行系统化记录与分析，已在实际开发过程中协助发现并定位多个影响性能或代码生成质量的工具链缺陷，为编译器优化与回归验证提供了重要支撑。下文结合平台主要功能界面，详细展示其核心功能。

\par

1.全局性能趋势分析

如图\ref{fig:summary}所示，界面用于展示历史Commit的整体性能概览，侧重于从宏观层面分析编译器性能随时间的演进趋势。该界面基于完整测试集，对不同Commit下的平均代码体积和平均执行周期进行统计与可视化展示，便于快速识别性能回退或异常波动，为后续深入分析提供依据；支持按测试集、测试平台以及芯片版本区分数据，同时展示测试集在不同优化等级及版本下的平均代码尺寸与平均执行周期。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/summary.png}
	\caption{全局性能趋势分析界面展示图}
	\label{fig:summary}
\end{figure}

2.单测试用例性能演化分析

如图\ref{fig:history}所示，界面用于跟踪单个测试用例在不同Commit下的性能变化情况，支持按时间序列展示其执行周期、代码尺寸以及指令打包效率等关键指标。通过该界面，开发者可以精确定位某一性能变化首次引入的Commit，从而显著提升性能回归分析的效率与准确性。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/history.png}
	\caption{单测试用例性能演化分析界面展示图}
	\label{fig:history}
\end{figure}


3.跨版本性能差异对比分析

如图\ref{fig:compare}所示，界面用于对任意两个Commit之间的性能指标进行对比分析。该界面不仅提供测试用例级别的执行周期与代码体积对比结果，还支持对生成的汇编代码进行逐行对照，帮助开发者从底层代码生成角度分析性能差异的根本原因，适用于优化效果验证与回归问题定位。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/compare.png}
	\caption{跨版本性能差异对比分析界面展示图}
	\label{fig:compare}
\end{figure}

4.本地性能测试报告上传

如图\ref{fig:custom}所示，界面用于上传本地生成的性能测试结果，并与Master分支的结果进行对比分析。该功能为开发者在本地修改编译器或新增优化策略后，快速验证其性能影响提供了便利，有效支持离线实验与在线结果的统一管理。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/custom.png}
	\caption{本地性能测试报告上传界面展示图}
	\label{fig:custom}
\end{figure}


%*********************************************************************
% 5.4 本章小结
%*********************************************************************
\section{本章小结}


