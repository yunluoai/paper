\chapter{实验结果与性能分析}


%*********************************************************************
% 5.1 GlobalISel代码生成正确性验证
%*********************************************************************
\section{GlobalISel代码生成正确性验证}


% 5.1.1 基本指令正确性验证
\subsection{基本指令正确性验证}
本节旨在验证DSP后端基本指令（除控制流指令及特殊指令之外的指令）的正确性，重点关注算术运算指令和内存访问指令的匹配和选择结果。为此本节设计了一个示例程序一，这个示例程序包含函数参数传递、内存读写操作和整数加法与乘法运算等操作，能够覆盖了DSP后端常见的指令选择路径。

\par

由于LLVM IR具有良好的目标无关性，且从C语言到LLVM IR的转换过程并非本文关注重点，本文在分析过程中省略前端生成IR的具体细节，直接展示从LLVM IR到目标机器码的转换流程，以突出指令选择与后端代码生成阶段的行为特征。


\subsubsection{1.LLVM IR输入}
示例程序一的LLVM IR如代码块\ref{lst:case_1_ir}所示，该示例程序包含了基本的算术与访存操作，后文将以此为基础分析指令选择过程中中间表示的演化。为了便于展示，已去除掉代码中的调试信息。

\lstset{language=c++}
\begin{lstlisting}[language=C++, caption={示例程序一的LLVM IR表示}, label={lst:case_1_ir}]
define dso_local i32 @testArith(i32 noundef %a, i32 noundef %b) {
	entry:
	%a.addr = alloca i32
	%b.addr = alloca i32
	store i32 %a, ptr %a.addr
	store i32 %b, ptr %b.addr
	%0 = load i32, ptr %a.addr
	%1 = load i32, ptr %b.addr
	%add = add i32 %0, %1
	%2 = load i32, ptr %a.addr
	%mul = mul i32 %add, %2
	ret i32 %mul
}
\end{lstlisting}


\subsubsection{2.GMIR生成阶段}
如图\ref{fig:case_1_gmir_gen_dump}所示，在GMIR生成阶段，LLVM IR被转换为与目标架构无关的GMIR。从中间结果可以观察到：

\begin{itemize}
	\item 
	alloca被映射为COPY指令，函数参数通过COPY指令从物理寄存器拷贝到虚拟寄存器。
	
	\item
	load与store分别被映射为G\_LOAD与G\_STORE。
	
	\item
	add与mul分别被映射为G\_ADD与G\_MUL。
	
	\item 
	ret被映射为RET。
	
\end{itemize}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_1_gmir_gen_dump.png}
	\caption{示例程序一的GMIR生成阶段Dump图}
	\label{fig:case_1_gmir_gen_dump}
\end{figure}

该结果表明，LLVM IR到GMIR的转换过程保持了原有运算语义与数据依赖关系，为后续后端处理提供了正确的输入。


\subsubsection{3.合法化阶段}
指令合法化阶段的核心任务，在于将GMIR中目标架构不直接支持的操作，转化为目标架构可以直接处理的合法形式。在本示例程序中，32位的G\_ADD、G\_MUL、G\_LOAD以及G\_STORE等指令均为DSP架构原生支持的操作，因此并未触发类型扩展及指令拆解等复杂的合法化过程。如图\ref{fig:case_1_legalize_dump}所示，合法化前后的指令序列在结构和语义上保持一致。这一结果表明，当前DSP合法化规则能够正确处理基本的算术运算与内存访问指令。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_1_legalize_dump.png}
	\caption{示例程序一的合法化阶段Dump图}
	\label{fig:case_1_legalize_dump}
\end{figure}


\subsubsection{4.寄存器组选择阶段}
在寄存器组选择阶段，编译器需要为每个虚拟寄存器分配合适的寄存器组。在当前的DSP后端实现中，所有参与整数算术运算的虚拟寄存器都被统一映射至GPRB中。如图\ref{fig:case_1_regbank_select_dump}所示，从寄存器组选择后的中间结果可以观察到，所有算术指令的操作数及结果均被分配到GPRB寄存器组，并且寄存器类型与对应操作数的位宽保持一致，符合DSP架构对整数运算的寄存器使用约束。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_1_regbank_select_dump.png}
	\caption{示例程序一的寄存器组选择阶段Dump图}
	\label{fig:case_1_regbank_select_dump}
\end{figure}

该结果表明所有参与算术运算的虚拟寄存器均被正确分配至通用寄存器组，同时未引入额外的跨寄存器组数据复制或冗余中间指令。


\subsubsection{5.机器指令选择阶段}
在机器指令选择阶段，GMIR被转换为DSP架构的目标机器指令。如\ref{fig:case_1_instr_select_dump}所示，从中间结果可以观察到，除了COPY指令外的所有指令都被正确的映射到DSP后端机器指令，COPY指令需要在后续阶段中单独处理。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_1_instr_select_dump.png}
	\caption{示例程序一的机器指令选择阶段Dump图}
	\label{fig:case_1_instr_select_dump}
\end{figure}


\subsubsection{6.最终代码生成阶段}
在完成寄存器分配以及指令调度等后续后端处理流程后，编译器最终生成了符合DSP指令集规范的目标代码。如图\ref{fig:case_1_final_dump}所示，生成的目标代码在指令顺序、操作数选择以及控制流结构等方面均与原始程序语义保持一致。这表明在该示例程序中，基于GlobalISel框架的代码生成流程能够在DSP后端上正确运行，实现了从高级LLVM IR到目标平台可执行机器指令的精准映射。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_1_final_dump.png}
	\caption{示例程序一的最终阶段Dump图}
	\label{fig:case_1_final_dump}
\end{figure}


% 5.1.2 控制流指令正确性验证
\subsection{控制流指令正确性验证}
除基本算术与内存访问指令这些基本指令外，控制流指令的正确生成和映射同样是验证编译器后端正确性的重要体现。本节针对对控制流相关指令的处理过程进行验证，重点覆盖比较与条件分支与函数调用两类典型控制流场景。


\subsubsection{1.比较+分支+跳转指令}
比较与条件分支是程序控制流构建的基础。在LLVM IR中，比较与条件分支通过icmp与br组合表达。为验证DSP后端对该类控制流指令的处理正确性，本节构建了一个同时包含比较、条件分支及无条件跳转的示例程序二，其LLVM IR如代码块\ref{lst:case_2_ir}所示。

\lstset{language=c++}
\begin{lstlisting}[language=C++, caption={示例程序二的LLVM IR表示}, label={lst:case_2_ir}]
define dso_local i32 @testBranch() {
	entry:
	%retval = alloca i32
	%a = alloca i32
	%b = alloca i32
	store i32 10, ptr %a
	store i32 20, ptr %b
	%0 = load i32, ptr %a
	%1 = load i32, ptr %b
	%cmp = icmp slt i32 %0, %1
	br i1 %cmp, label %if.then, label %if.else
	
	if.then:
	store i32 0, ptr %retval
	br label %return
	
	if.else:
	store i32 1, ptr %retval
	br label %return
	
	return:  %2 = load i32, ptr %retval
	ret i32 %2
}
\end{lstlisting}

针对该示例程序，在GlobalISel各关键阶段中的处理过程如下：

\begin{itemize}
	\item
	在GMIR生成阶段，LLVM IR中的比较指令被正确转换为G\_ICMP，其比较谓词与操作数保持一致；条件跳转指令被转换为G\_BRCOND，并以比较结果作为分支条件。
	
	\item
	在合法化阶段，由于DSP架构支持整数比较操作，无需进一步拆分，相关指令保持原有结构。
	
	\item 
	在寄存器组选择阶段，编译器为比较操作及其结果所涉及的虚拟寄存器分配了合适的寄存器组，确保比较结果能够以符合DSP架构约定的方式参与后续控制流指令。
	
	\item 
	在机器指令选择阶段，G\_ICMP与后续的G\_BRCOND会被联合处理，映射为DSP架构下的比较指令与条件跳转指令，比较结果通过条件码寄存器传递，从而完成分支控制。
	
\end{itemize}

如图\ref{fig:case_2_final_dump}所示，在函数入口基本块中，比较指令首先生成条件码寄存器状态，随后通过条件跳转指令根据比较结果在两个后继基本块之间进行分支选择，验证了比较与条件分支指令的正确映射。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_2_final_dump.png}
	\caption{示例程序二入口基本块的最终阶段Dump图}
	\label{fig:case_2_final_dump}
\end{figure}

如图\ref{fig:case_2_final_dump_2}所示，条件判断成立时进入if.then基本块，不成立则进入if.else基本块，两个基本块各自执行相应的逻辑操作，且在块末尾均通过无条件跳转指令，汇合到同一个返回基本块中。从最终生成的机器码结果来看，各分支基本块间的跳转关系，以及这些分支块与返回块的连接方式，均与LLVM IR所定义的控制流结构一致，未产生任何额外的控制流变动。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_2_final_dump_2.png}
	\caption{示例程序二条件分支基本块的最终阶段Dump图}
	\label{fig:case_2_final_dump_2}
\end{figure}

从实验结果可以观察到，在LLVM IR向目标代码的转换过程中，比较条件及其对应的分支目标均保持一致，程序控制流未发生偏移或错误跳转，实验结果验证了比较、分支与跳转指令选择的正确性。


\subsubsection{2.函数调用指令}
函数调用是一类重要的控制流操作，其正确性依赖于调用约定、参数传递机制以及返回值处理等多个环节。为验证DSP后端在GlobalISel框架下对函数调用指令的处理正确性，构造了一个简单的示例程序四，其中main函数调用前文定义的testBranch函数，其LLVM IR如代码块\ref{lst:case_4_ir}所示。

\lstset{language=c++}
\begin{lstlisting}[language=C++, caption={示例程序四的LLVM IR表示}, label={lst:case_4_ir}]
define dso_local i32 @main() {
	entry:
	%retval = alloca i32
	store i32 0, ptr %retval
	%call = call i32 @testBranch()
	ret i32 %call
}
\end{lstlisting}

针对该示例程序，函数调用在各阶段的处理过程如下：

\begin{itemize}
	\item
	在GMIR生成阶段，call指令被转换为与调用约定相关的一系列包括参数准备、调用指令以及返回值接收等操作的GMIR指令。
	
	\item
	在合法化阶段，合法化前后指令结构保持一致，表明DSP后端的合法化规则能够覆盖该类函数调用场景的基本操作需求。
	
	\item 
	在寄存器组选择阶段，函数参数与返回值在符合DSP ABI的规则下被分配至DSP架构规定的寄存器或栈位置。
	
	\item 
	在机器指令选择阶段，与调用相关的GMIR指令会被映射为DSP架构支持的跳转与返回指令。
	
\end{itemize}

如图\ref{fig:case_4_final_dump}所示，实验结果表明DSP后端在GlobalISel框架下能够正确完成函数调用相关控制流的指令选择，从而保证了跨函数控制流的正确传递。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_4_final_dump.png}
	\caption{示例程序四的最终阶段Dump图}
	\label{fig:case_4_final_dump}
\end{figure}


%*********************************************************************
% 5.2 GlobalISel优化策略有效性验证
%*********************************************************************
\section{GlobalISel优化策略有效性验证}
为验证本文所提出优化策略的有效性，本节通过一系列实验分别对两个阶段的优化效果进行验证。首先进行基于典型样例的针对性验证，构造一个符合优化触发条件的典型测试程序，通过观察优化前后的中间表示变化，判断优化是否正确触发并产生预期结果。然后进行系统性量化评估，在Embench基准测试集上开展实验。实验通过对比优化开启与优化关闭两种配置下生成的代码，从代码体积与执行周期两个维度进行量化分析，从而系统评估优化对性能产生的实际影响。


\subsection{合法化前优化策略验证}


\subsubsection{1.典型样例验证}
为验证合法化前优化是否有效，本节以内存操作优化为例设计了示例程序五，程序包含一个内存拷贝函数，用于从源地址拷贝16字节的32位整型数据到目标地址，其LLVM IR如代码块\ref{lst:case_5_ir}所示。

\lstset{language=c++}
\begin{lstlisting}[language=C++, caption={示例程序五的LLVM IR表示}, label={lst:case_5_ir}]
define void @main(ptr %dst, ptr %src) {
	call void @llvm.memcpy.p0.p0.i32(ptr %dst, ptr %src, i32 16, i1 0)
	ret void
}

declare void @llvm.memcpy.p0.p0.i32(ptr, ptr, i32, i1)
\end{lstlisting}

在未启用优化的编译流程中，内存拷贝以函数调用形式实现。在启用了本文实现的合法化前优化后，编译器在GMIR生成阶段将此内存拷贝调用识别并转换为等价的基础内存操作指令序列。图\ref{fig:case_5_before_dump}与图\ref{fig:case_5_after_dump}分别展示了优化前后的中间表示。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_5_before_dump.png}
	\caption{示例程序五优化前Dump图}
	\label{fig:case_5_before_dump}
\end{figure}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_5_after_dump.png}
	\caption{示例程序五优化后Dump图}
	\label{fig:case_5_after_dump}
\end{figure}

对比两图可以看出，memcpy指令在优化后被成功替换为一组G\_LOAD与G\_STORE指令序列，完成了从内置函数到基础内存操作的转换，证明了该优化策略的有效性。


\subsubsection{2.系统性量化评估}
以优化等级O2为例，选取Embench测试集中的10个样例进行测试。在开优化和不开优化两种条件下，对这些样例的代码体积和执行周期进行统计并通过可视化方式呈现优化前后的量化对比结果。

\par

代码体积是衡量编译器后端代码生成质量的重要指标之一，尤其在DSP这类嵌入式场景中，受限的程序存储空间使得指令密度成为影响系统规模与功耗水平的关键因素。因此，分析不同指令选择方案对最终生成代码体积的影响，对于评估GlobalISel框架下的优化效果具有重要意义。

\par

本节及后续章节都基于llvm-size工具来完成代码体积的量化，并以目标文件中text段大小作为代码体积的度量指标。text段大小能够直接反映指令选择与代码生成阶段所产生的指令数量与编码密度，同时有效规避调试信息、符号表等非执行内容对统计结果的干扰。

\par

从图\ref{fig:pre_optimization_code_size}可以观察到，除了crc32样例的缩减率是负值之外，其余样例的缩减率均为正值，这表明大多样例的代码体积都有减小，其中edn样例的效果最明显。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/pre_optimization_code_size.png}
	\caption{合法化前优化对代码体积提升效果图}
	\label{fig:pre_optimization_code_size}
\end{figure}

执行周期是衡量编译器后端优化效果最直接、也是最具代表性的性能指标之一。对于DSP这种以吞吐率和实时性为核心设计目标的处理器架构而言，程序执行周期的变化能够直观反映编译器后端各阶段的决策对实际运行性能的影响。因此，本节围绕执行周期这一维度，对不同指令选择方案在DSP平台上的运行表现进行对比分析。

\par

本节及后续章节的执行周期测量基于DSP工具链配套的仿真器环境完成。在仿真环境中，仿真器能够在程序执行过程中精确统计指令发射与执行情况，并直接给出程序完成所消耗的总周期数。

\par

为保证不同指令选择方案在执行周期统计上的可比性，本节在测量时统一采用相同的测试程序、输入数据以及运行环境配置。除此之外，本节关注程序主体计算阶段的执行周期，避免初始化、调试输出等非核心逻辑对统计结果产生干扰。实验最终得到的执行周期能够真实地反映编译器后端生成的代码在DSP架构上的运行效率。

\par

从图\ref{fig:pre_optimization_cycle}可以观察到，所有样例的执行周期缩减率都为正值，这表明所有的样例的执行效率均提高了。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/pre_optimization_cycle.png}
	\caption{合法化前优化对执行周期提升效果图}
	\label{fig:pre_optimization_cycle}
\end{figure}

以上实验结果表明：本文实现的面向DSP后端的合法化前优化在大多数场景下都能有效减少代码体积并提高执行效率。


\subsection{合法化后优化策略验证}


\subsubsection{1.典型样例验证}
为验证合法化后优化是否有效，本节以常量乘法强度削弱为例设计了示例程序六，程序包含一个32位整型乘法指令，其LLVM IR如代码块 \ref{lst:case_6_ir} 所示。

\lstset{language=c++}
\begin{lstlisting}[language=C++, caption={示例程序六的LLVM IR表示}, label={lst:case_6_ir}]
define dso_local i32 @main() #0 align 16 {
entry:
	%retval = alloca i32, align 4
	%a = alloca i32, align 4
	store i32 0, ptr %retval, align 4
	store i32 17, ptr %a, align 4
	%0 = load i32, ptr %a, align 4
	%mul = mul nsw i32 %0, 33
	ret i32 %mul
}
\end{lstlisting}

在未启用优化的编译流程中，乘法操作以一条硬件乘法指令的形式实现。在启用了本文实现的合法后优化后，编译器在机器指令选择阶段前将乘法指令替换为更优的指令组合。图\ref{fig:case_5_before_dump}与图\ref{fig:case_5_after_dump}分别展示了优化前后的中间表示。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_6_before_dump.png}
	\caption{示例程序六优化前Dump图}
	\label{fig:case_6_before_dump}
\end{figure}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/case_6_after_dump.png}
	\caption{示例程序六优化后Dump图}
	\label{fig:case_6_after_dump}
\end{figure}

图\ref{fig:case_6_before_dump}与图\ref{fig:case_6_after_dump}展示了优化前后的GMIR对比，从图中可以看出优化前的G\_MUL指令在优化后被成功替换为G\_SHL与G\_ADD指令的组合。此转换证明了常量乘法强度削弱优化在合法化后阶段被正确触发并应用，达到了以低成本操作替代高成本运算的优化目标。


\subsubsection{2.系统性量化评估}
以优化等级O2为例并选取与5.2.1节A相同的10个样例，在开优化和不开优化两种条件下，对这些样例的代码体积和执行周期进行统计并通过可视化方式呈现优化前后的量化对比结果。

\par

从图\ref{fig:post_optimization_code_size}可以观察到，mont64样例的代码体积缩减效果最为显著，缩减率高达16.2749\%；qrduino、slre、picojpeg等样例也实现了2\%以上的正向缩减；仅st样例出现小幅体积增加。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/post_optimization_code_size.png}
	\caption{合法化后优化对代码体积提升效果图}
	\label{fig:post_optimization_code_size}
\end{figure}

从图\ref{fig:post_optimization_cycle}可以观察到，大部分样例的执行周期均获得正向缩减，其中mont64样例的缩减效果最为突出，执行周期缩减率高达18.3536\%；edn、md5sum、picojpeg等样例也实现了1\%至3\%的性能提升；仅huffbench与st样例的执行周期数出现了小幅增加。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/post_optimization_cycle.png}
	\caption{合法化后优化对执行周期提升效果图}
	\label{fig:post_optimization_cycle}
\end{figure}

以上实验结果表明：本文实现的面向DSP后端的合法化后优化在大多数场景下都能有效减少执行周期并提高执行效率。


%*********************************************************************
% 5.3 GlobalISel综合性能对比分析
%*********************************************************************
\section{GlobalISel综合性能对比分析}
上一节已通过对比实验分别验证了合法化前、后优化策略的有效性，为全面评估GlobalISel框架相较于传统指令选择方案的综合性能优势，本节从代码大小、执行周期以及编译时间三个维度出发，对基于DAG的指令选择、未优化的全局指令选择以及优化后的全局指令选择来进行全方面的对比。


% 5.3.1 代码体积对比
\subsection{代码体积对比}


\subsubsection{1.实验设置与统计方法}
本节选取Embench作为测试集，对每个基准程序分别在四个优化等级下进行编译，并统计对应生成目标文件的text段大小。对于同一测试样例与优化等级，取单次编译结果作为该样例的代码体积。随后，把测试集中所有基准程序的结果进行平均计算，得到各个优化等级下的平均代码段体积，用于不同指令选择方案之间的对比分析。


\subsubsection{2.实验结果分析}
图\ref{fig:size_contrast}给出了在Embench测试集上，未引入优化的GlobalISel与引入优化后的GlobalISel在不同优化等级下的平均代码段体积对比结果。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/size_contrast.png}
	\caption{优化前后平均代码段体积对比图}
	\label{fig:size_contrast}
\end{figure}

从整体上看，在4个优化等级下的优化后GlobalISel方案最终生成的平均代码体积更小，而且在O0性能等级下体现更加明显，表明即使是不进行高层LLVM IR的优化，在后端指令选择和指令组合方面提高的优化手段亦可以减小指令冗余、提高指令密度。高优化等级下，代码体积下降更加收敛，因为高层LLVM IR已经展开得很充分，有些冗余已经在前端或中端去掉，后端指令选择优化对代码体积的影响更多是精细化的指令密度改进，而非数量级的减少。


\subsubsection{3.实验结论}
从实验结果来看，相较于未优化的GlobalISel实现，引入针对DSP架构特点的指令选择与指令组合优化后，编译器在各优化等级下均生成了更紧凑的目标代码。这表明本文提出的优化策略不仅在性能层面有效，还在代码体积这一关键指标上取得效果，为后续嵌入式场景的实际部署提供了有力支撑。


% 5.3.2 执行周期对比
\subsection{执行周期对比}


\subsubsection{1.实验设置与统计方法}
实验同样基于Embench测试集展开。为确保数据的稳定性和统计意义，每个基准程序均在相同的硬件平台和编译配置下独立运行多次，以消除单次测量中随机扰动的影响。具体流程为：每个样例执行10次，去掉最高和最低各两次结果，取剩余6次的平均值作为该样例的执行周期。最后，对所有样例的结果取总平均值，得到该优化等级下的整体执行周期。该统计方式能够有效平衡测量精度与实验成本，在保证数据稳定性的同时，避免个别异常运行结果对整体趋势判断产生干扰。

\subsubsection{2.实验结果与分析}
图\ref{fig:cycle_contrast}给出了在Embench测试集上，不同指令选择方案在各优化等级下的平均执行周期对比结果。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/cycle_contrast.png}
	\caption{不同指令选择方案平均执行周期对比图}
	\label{fig:cycle_contrast}
\end{figure}

从实验结果可以观察到，相较于未优化的GlobalISel实现，引入针对DSP架构的指令选择与指令组合优化后，程序在所有优化等级下的平均执行周期均呈现出下降趋势。这表明，在高层LLVM IR优化与后端优化协同作用的场景中，GlobalISel所引入的目标相关指令匹配、冗余指令消除以及寄存器组绑定优化，能够进一步挖掘DSP架构的指令级并行潜力，从而在整体执行效率上获得持续收益。


\subsubsection{3.实验结论}
从实验结果来看，DSP后端在引入针对其目标架构特性的GlobalISel优化后，编译器生成代码在执行周期维度上取得了稳定且可观的性能提升。并且该提升在不同优化等级下均具有一致性，说明其并非依赖特定编译配置，而是源于指令选择框架与目标相关优化策略在整体设计上的协同改进。这一结果进一步验证了前文提出的优化方法在实际运行性能上的有效性。


% 5.3.3 编译时间对比
\subsection{编译时间对比}
除了代码体积和执行周期这两个性能指标外，编译时间作为一项关键的工程指标，直接反映了编译器的可用性与开发迭代效率，尤其在需要持续进行性能优化与回归测试的编译器开发实践中，后端编译阶段的耗时变化将对整体开发效率产生显著影响。为此，本节将从编译时间维度出发，系统性地对比分析不同指令选择方案在DSP后端上的性能表现。


\subsubsection{1.度量方法与相关指标说明}
本节基于Clang自带的编译时间追踪机制来对编译时间进行量化分析，该机制能够对编译过程中各阶段的执行时间进行精细化统计，从而为分析编译器性能瓶颈与优化效果提供可靠的数据支撑。图\ref{fig:compile_time_example}中展示了部分关键时间指标及其在不同编译阶段的分布情况。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/compile_time_example.png}
	\caption{不同编译阶段时间指标图}
	\label{fig:compile_time_example}
\end{figure}

其中，各时间指标的含义如下：

\begin{itemize}
	\item
	User Time（用户态时间）：表示CPU在用户态执行编译器自身代码所消耗的时间，仅反映编译器逻辑计算的开销，不包含操作系统内核相关操作。
	
	\item
	System Time（系统态时间）：表示CPU在内核态执行系统调用（如文件读写、内存管理、进程调度等）所消耗的时间，属于编译过程中的系统辅助开销。
	
	\item 
	User+System Time（用户态加系统态时间）：反映CPU在该阶段用于计算的总耗时，是用户态和系统态时间的累加，但不包含I/O等待和CPU空闲时间。
	
	\item 
	Wall Time（壁钟时间）：指从编译阶段开始到结束所消耗的实际物理时间。在实际场景中，这一指标最能直观反映用户实际感知到的编译等待时长，因此也是本文关注的核心量化指标。
	
\end{itemize}

LLVM编译流程可划分为以下几个阶段：

\begin{itemize}
	\item
	Front end（前端）：负责源代码解析、语法分析、语义分析等核心操作，核心作用是将高级语言代码转换为中间表示形式。
	
	\item
	LLVM IR generation（LLVM IR生成）：负责将前端分析的结果转换为LLVM IR，为后续优化和代码生成奠定基础。
	
	\item 
	Optimizer（优化器）：负责对LLVM IR进行多级优化，包括控制流优化、数据流优化及目标无关优化等。
	
	\item 
	Machine code generation（机器码生成）：作为编译器后端的核心环节，该阶段负责指令选择、寄存器分配、指令调度以及最终目标机器码的生成。
	
\end{itemize}

由于指令选择阶段在LLVM后端中与其他流程的耦合度较高，难以单独抽离出来进行精确量化，因此本节在编译时间的分析中，将关注点放在后端整体执行时间上。具体而言，统计Machine Code Generation阶段的Wall Time，以此作为后端编译开销的统一度量标准。这种统计方式在保证分析结果可比性和稳定性的同时，能够有效反映后端相关优化对实际编译时间的影响，为后续性能评估提供依据。


\subsubsection{2.实验设置与统计方法}
为降低单次测量中环境噪声与随机波动对实验结果的影响，实验采用多次重复实验的统计方法。具体而言，在保持实验环境与配置完全一致的条件下，对每个测试样例分别独立执行10次完整的编译流程。在结果统计阶段，剔除两个最大值和两个最小值后再对剩余数据取平均值，以此作为该样例在对应优化等级下的编译时间。最后对Embench测试集中22个基准程序的结果汇总并进一步取平均值，得到不同优化等级下的平均编译时间，以此用于不同指令选择方案之间的对比分析。


\subsubsection{3.实验结果与分析}
图\ref{fig:compile_time_contrast}给出了在Embench测试集上两种指令选择方案在不同优化等级下的平均编译时间对比结果。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/compile_time_contrast.png}
	\caption{两种指令选择方案平均编译时间对比图}
	\label{fig:compile_time_contrast}
\end{figure}

图\ref{fig:compile_time_contrast}中结果显示，四个优化等级下GlobalISel的平均编译时间均更低。这个趋势在O0与O1优化等级下更加明显，这表明在中端优化尚未充分展开的情况下，指令选择框架自身的设计差异就已经对后端编译效率产生了影响。之所以出现这样的结果，主要是因为GlobalISel在指令选择阶段采用的基于规则匹配与直接构造Machine IR的流程，相较于传统基于DAG的指令选择方式，其构建与遍历成本更低，整体流程更线性。此外，GlobalISel在GMIR层面引入的早期规范化与合并优化，也在一定程度上减少了后续Pass的处理负担，从而降低了后端编译的整体开销。


\subsubsection{4.实验结论}
从实验结果上来看，DSP后端中GlobalISel在编译时间上相比SelectionDAG具备稳定优势，且该优势在各优化等级下均保持一致。这说明该优势并非源于特定的优化配置，而是来自指令选择框架本身在流程设计和中间表示处理上的效率优化。这一特性使GlobalISel更适合应用在需要频繁编译和快速迭代的工程场景，为后续编译器优化和性能验证提供了扎实的基础。


%*********************************************************************
% 5.4 测试评估平台功能展示
%*********************************************************************
\section{测试评估平台功能展示}
测试评估平台围绕编译器工具链的持续迭代需求来进行设计。平台集成了性能数据采集、历史回归分析、版本对比以及汇编级诊断等功能。平台通过系统化地记录与分析不同Commit在统一测试集上的性能表现，已在实际开发过程中协助作者发现并定位多个编译器缺陷，为编译器优化与回归验证提供了重要支撑。下文结合平台主要功能模块，详细展示其核心功能。


\subsubsection{1.全局性能趋势分析模块}
如图\ref{fig:summary}所示，该模块用于展示历史Commit的整体性能概况。模块基于完整测试集，对不同Commit下的平均代码体积和平均执行周期进行统计与可视化展示，便于快速识别性能回退或异常波动，为后续的分析提供依据。除此之外，模块还支持按测试集、测试平台以及芯片版本区分数据，同时展示测试集在不同优化等级及版本下的平均代码体积与平均执行周期。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/summary.png}
	\caption{全局性能趋势分析界面展示图}
	\label{fig:summary}
\end{figure}


\subsubsection{2.单测试用例性能演化分析模块}
如图\ref{fig:history}所示，该模块用于展示单个测试用例在不同Commit下的性能变化情况，并支持按时间序列展示其执行周期、代码体积以及指令打包效率等关键指标。通过该模块，开发者可以精确定位某一性能变化首次引入的Commit，从而显著提升性能回归分析的效率与准确性。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/history.png}
	\caption{单测试用例性能演化分析界面展示图}
	\label{fig:history}
\end{figure}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/compare.png}
	\caption{跨版本性能差异对比分析界面展示图}
	\label{fig:compare}
\end{figure}


\subsubsection{3.跨版本性能差异对比分析模块}
如图\ref{fig:compare}所示，该模块用于对任意两个Commit之间的性能指标进行对比分析。模块不仅提供测试用例级别的执行周期与代码体积对比结果，还提供样例汇编代码对比的功能，以此帮助开发者从底层代码生成角度分析性能差异的根本原因，适用于优化效果验证与回归问题定位的情景。


\subsubsection{4.本地性能测试报告上传模块}
如图\ref{fig:custom}所示，该模块用于上传本地生成的性能测试结果，并与Master分支的结果进行对比分析。该模块为开发者在本地修改编译器或新增优化策略后的快速验证提供了便利。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/custom.png}
	\caption{本地性能测试报告上传界面展示图}
	\label{fig:custom}
\end{figure}


%*********************************************************************
% 5.5 本章小结
%*********************************************************************
\section{本章小结}
本章首先用一系列有代表性的示例程序来验证面向DSP后端的GlobalISel框架代码生成的正确性。示例程序覆盖了指令合法化、寄存器组选择以及机器指令选择等关键阶段，从而确保了GlobalISel在DSP平台上的功能正确性。


\par

在系统性地验证了GlobalISel的正确性之后，本章接着对编译时间、代码体积和执行周期等关键性能指标进行了全面的对比分析。实验结果表明，优化后的GlobalISel在各关键环节均能保持原始程序语义与数据依赖关系，其生成的目标代码符合DSP指令集规范与控制流逻辑，并且在性能上有明显的提升。

\par

最后本章展示了测试评估平台的核心功能界面，其中包括全局性能趋势分析、单测试用例性能演化追踪、跨版本性能对比和本地测试报告上传等界面。这些功能为实验的正确性验证和性能分析提供了高效的数据支持与可视化手段，并有助于DSP工具链快速定位性能回退与代码生成缺陷。

