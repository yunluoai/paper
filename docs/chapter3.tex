\chapter{面向DSP的全局指令选择优化策略}
与SelectionDAGISel相比，GlobalISel在性能潜力上存在先天局限。其根源在于两者的设计目标与底层模型存在本质差异。SelectionDAGISel的核心理念是针对特定硬件进行深度优化。它基于一个全局的、具有丰富语义信息的有向无环图模型，这使得编译器能够在整个函数的范围内进行详尽的指令选择与优化，从而在匹配复杂指令模式、优化调度和执行效率方面具有理论上的优势。换言之，它牺牲了部分编译速度和通用性，以换取为特定架构生成更优代码的潜力。

\par

反观GlobalISel，其首要设计目标是提升编译速度与增强跨平台可维护性。它采用一种更线性、增量式的处理模型，放弃了全局DAG所支持的综合性优化视角。这种通用化、模块化的设计使其在适配新架构时更加便捷，但也意味着它在进行指令选择时，天然缺乏进行全局性、深度窥孔优化的能力。因此，当其面对DSP这类对指令级效率和硬件特性匹配要求极高的专用架构时，这种通用性与性能最优之间的内在矛盾便被放大，直接导致了一些性能问题。

\par

为解决这些性能问题，本文基于面向DSP的GlobalISel框架，提出了一种分阶段协同优化方案，该方案分为合法化前的通用冗余消除与合法化后针对DSP架构的特定优化两个主要阶段，通过递进式优化兼顾通用中间表示的冗余消除与DSP硬件架构的特性适配。本章后续将详细阐述面向DSP的全局指令选择优化体系的整体设计思路，拆解分阶段优化策略的具体实现流程，并对其中涉及的关键技术细节进行深入剖析。


%*********************************************************************
% 3.1 优化策略分析与设计
%*********************************************************************
\section{优化策略分析与设计}
经过GMIR生成、指令合法化、寄存器组选择以及机器指令选择4个Pass之后，原来的LLVM IR转换成了MIR。尽管这一流程已经实现了指令选择的目标，但是转换之后生成的代码质量相比于SelectionDAGISel较差。这个差距主要体现在指令数量增加，专用指令利用率低，寄存器选取不够精细高效等。

\par

为了提升GlobalISel生成代码的质量并缩小其与SelectionDAGISel之间的差距，本文引入了包括CSE（Common Subexpression Elimination, 公共子表达式消除）、KnownBits Analysis（已知位分析）以及Combiner（合并优化）等优化策略。这些优化策略通过减少重复子表达式、利用比特级已知信息指导指令选择，并在保持语义等价的前提下合并和简化指令序列，从而降低了指令冗余度，提升了生成代码的性能表现。


% 3.1.1 优化策略理论依据
\subsection{优化策略理论依据}
程序编译过程（尤其是从高层LLVM IR编译到目标特定低级指令时）必然引入大量的冗余，这些冗余由计算冗余（公共子表达式重复计算）、数据冗余（冗余拷贝）和表示冗余（大量更复杂的指令序列可以用更简单的指令序列来表示）等引起。优化的任务就是要系统地检测、消除这些冗余，在程序语义不变的前提下提高程序生成代码执行效率、代码密度、硬件利用率等。

\par
GlobalISel与SelectionDAGISel在代码质量上的差异，根本原因在于二者的设计目标与实现方式不同。SelectionDAGISel是针对特定架构定制的设计，其核心中间表示SelectionDAG天然具备对基本块内局部计算图进行重写、合并与规约的能力，从而能够在指令选择阶段有效消除冗余计算；GlobalISel为了支持不同架构指令集的特性而采用通用中间表示+模块Pass的设计，因此在中间代码产生时会不可避免地产生冗余，产生这种冗余的原因主要有三点：

\begin{enumerate}
	\item
	通用化转换带来的语义冗余：为保证跨架构语义的一致性，GlobalISel在LLVM IR向GMIR转换及指令合法化阶段，会将复杂运算拆分为一系列简单的原子指令。例如，将DSP架构的乘加运算（MAC）拆分为乘法与加法指令，将宽类型数据访问拆分为多次窄类型加载/存储指令，这种拆分虽保证了语义正确性，却引入了大量指令级冗余。
	
	\item
	寄存器组选择的局部性局限：在寄存器组选择阶段，寄存器组的分配以基本块为粒度，没有充分考虑函数级的全局数据流依赖，容易产生频繁地跨基本块数据复制。例如循环变量在不同基本块中被分配到不同寄存器组，需通过专用复制指令完成数据迁移，这显著增加了执行延迟。
	
	\item 
	硬件特性适配的滞后性：机器指令选择阶段的主要目的是完成从通用GMIR到目标指令的语义映射，因而默认采取的是局部的、简单的一对一语义映射。复杂指令模式的识别被推迟到了较晚的阶段，编译器无法及时识别跨越多条GMIR指令的复杂语义，也就无法完整、充分地挖掘硬件中专用功能单元性能潜力。
	
\end{enumerate}

从理论上讲，高效优化的前提是要基于精确可靠的程序分析。数据流分析（如CSE所依赖的可用表达式分析）揭示了值是如何在程序中产生和传播的；而信息流分析（如KnownBits分析）则是在位级层面推断值的范围。这些分析保证了上述优化变换的可行性及可靠性。

\par

从实际上讲，DSP处理器指令集中有一些专门针对特定模式的指令设计，如乘加、向量加载/存储及多数据并行运算指令。优化需要具备识别指令模式的能力，能在合适的阶段将通用操作序列转化成高度优化的硬件操作命令。只有在分析与变换机制的支撑下才能使编译器既能保证通用性，又能生成高性能、高效率的目标代码。


% 3.1.2 关键优化技术分析
\subsection{关键优化技术分析}


\subsubsection{1.公共子表达式消除}
公共子表达式消除是一种经典的编译优化技术，其核心目标在于识别并消除程序中重复计算相同表达式的冗余操作。该优化能够通过避免冗余计算与减少不必要的寄存器占用，从而有效精简代码体积并降低执行延迟。在指令选择阶段，如果一个表达式的值已经被计算过，并且其操作数在后续代码中未被重新定义，则可以复用之前的计算结果，避免重复计算，从而减少冗余指令的产生。如代码块\ref{lst:cse_before}和代码块\ref{lst:cse_after}所示，在优化前b+c被计算了3次，优化后只需要计算1次。

\begin{figure}[htbp]
	\centering
	\begin{minipage}[t]{0.48\linewidth}
		\captionsetup{type=lstlisting}
		\begin{lstlisting}[language=C++, caption={CSE优化前}, label={lst:cse_before}]
	a = b + c;
	d = b + c;
	e = b + c * 2;
	f = (b + c) * 3;

		\end{lstlisting}
	\end{minipage}\hfill
	\begin{minipage}[t]{0.48\linewidth}
		\captionsetup{type=lstlisting}
		\begin{lstlisting}[language=C++, caption={CSE优化后}, label={lst:cse_after}]
	temp = b + c;
	a = temp;
	d = temp;
	e = b + c * 2;
	f = temp * 3;
		\end{lstlisting}
	\end{minipage}
\end{figure}

与传统的CSE不同，GlobalISel使用了Continuous CSE（持续CSE）策略。Continuous CSE会在指令创建阶段检查是否已经存在语义等价的表达式，一旦发现可复用的结果便直接进行替换，从而消除不必要的冗余计算指令。与基于全函数或全基本块扫描的传统CSE不同，Continuous CSE主要作用于基本块内部，以增量式方式维护可消除的表达式集合，在不引入额外全局分析开销的前提下实现有效的冗余消除。这种局部的优化策略能够降低指令冗余，在保持优化效果的同时提升编译效率。

\par

CSE在消除冗余指令、降低寄存器使用压力的同时，也为后续优化创造了更多可能性。在指令合并优化阶段，复用公共子表达式的计算结果常常能带来更多的合并优化机会。例如，当多个计算共享同一子表达式时，合并优化可通过识别并整合这些冗余的计算模式，进一步简化指令序列，从而提升代码的整体执行效率与资源利用率。


\subsubsection{2.已知位分析}
已知位分析属于一种静态推断寄存器各位已知状态的方法，通过向其他Pass提供已知位信息，以此支持后面各类优化变换，这项分析跟踪每个位的已知状态来帮助优化器做决策，核心目标是在不带来额外运行时开销的情况下，尽量提前拿到寄存器值的准确信息，进而辅助常量传播、指令简化以及后面合并优化决策。该分析借助对寄存器里必然为0或必然为1的比特位加以建模，为优化器给出细粒度的位级语义信息。

\par

在具体的实现上，已知位分析需要为每个寄存器维护两个位掩码：KnownZeros和KnownOnes。其中KnownZeros用于标记寄存器中所有必然为0的位，相对应的KnownOnes则用于标记寄存器中所有必然为1的位。在指令流的传播过程中，这两个掩码会随着指令语义不断更新，使寄存器的比特级已知信息逐步得到完善。代码块\ref{lst:known_bits_case}展示了已知位分析在逻辑运算中的效果。

\lstset{language=c++}
\begin{lstlisting}[language=C++, caption={已知位分析示例}, label={lst:known_bits_case}]
	int test(int a) {
		int b = a & 0xFFFF;   // 低16位保留，高16位必为0
		int c = b | 0x10000;  // 第17位必为1
		return c;
	}
\end{lstlisting}

编译器通过上述分析，能够推断出变量b的高16位恒为0，变量c的第17位恒为1。这种位级确定性信息在后续优化中具有重要价值：一方面可用于消除冗余的掩码、扩展或条件判断指令；另一方面也为指令合并和目标指令的匹配提供了更精确的语义约束，从而支持生成更紧凑、更高效的机器代码。


\subsubsection{3.合并优化}
合并优化是一种将特定指令模式转换为更高效形式的编译优化技术。在GlobalISel框架中，合并优化是提升生成代码质量的重要手段。合并优化的目的是消除冗余的指令、简化表达式，并通过合并常见的低级操作模式来缩减代码规模、提升执行效率。合并优化可以充分利用目标架构的复杂指令，将多条简单指令合并为语义等价的单一指令，从而减少计算开销、降低寄存器压力，并减少对内存系统的访问次数。

\par

合并优化也可以看作是Peephole Optimization（窥孔优化）的一种推广，与传统窥孔优化局限于固定长度的相邻指令窗口不同，合并优化的作用范围显著扩大，它能够在更长的指令序列乃至跨基本块的范围内进行模式识别与优化重写，从而支持对更复杂、更分散的指令模式进行整合与简化。该优化策略的理论基础主要来源于以下几个方面的观察：

\begin{itemize}
	\item
	在低级代码生成过程中，为了便于表达中间计算结果，编译器会产生一系列指令结构简单但语义相关的指令序列，这会导致生成的指令存在冗余。目标架构如果有语义等价但更为复杂的单条指令形式，这些冗余的指令序列通常可以被这条高效指令所替代，从而减少了指令数量以及中间结果的产生。
	
	\item
	指令之间的数据流局部性比较强。相邻的指令会共享操作数或者存在直接的定义和使用关系，这为编译器识别可合并的操作模式提供了天然条件，可以使合并优化在保持程序语义不变的情况下对一系列指令进行整体的重构。
	
	\item 
	随着现代处理器指令集日益丰富，乘累加、融合算术以及向量化等复杂指令日益普及。合并优化在通用中间表示与这些复杂目标指令之间发挥着关键衔接作用，也是影响编译器利用目标机器计算能力的紧要因素。
	
\end{itemize}

在GlobalISel中，合并优化贯穿于指令选择的各个关键阶段，持续对中间表示进行等价的模式重写和规约。该过程逐步引导中间表示向更符合目标架构特性的形式演进，从而在保持整体编译流程模块化的同时，有效提升最终生成代码的质量。其具体工作流程如图\ref{fig:combiner}所示。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/combiner.png}
	\caption{GlobalISel合并优化流程示意图}
	\label{fig:combiner}
\end{figure}


% 3.1.3 面向DSP的优化设计
\subsection{面向DSP的优化设计}
单一的优化策略难以应对复杂的代码生成需求，因此有必要构建一个多策略协同的优化体系。本章以合并优化为核心，结合公共子表达式消除、已知位分析及窥孔优化等多种技术，系统探讨全局指令选择阶段的综合优化方法。由于公共子表达式消除等通用优化在框架中已有成熟的实现，实际工程中仅需调用相关接口即可，因此下文将重点对合并优化的设计与实现过程进行详细论述。

\par

为在GlobalISel框架中实现高效且可扩展的DSP优化方案，本章采用了一种混合式实现路径：结合TableGen声明式规则描述与C++手动回调逻辑。具体而言，基于TableGen的GICombiner机制主要用于描述可合并指令的结构化模式。通过在td文件中定义GICombineRule，能够以声明式的方式刻画指令之间的拓扑关系、操作码组合以及操作数约束条件。TableGen在编译期间会自动将这些规则转换为对应的匹配与执行代码，从而避免手工编写复杂的匹配逻辑，并保证了规则匹配过程的高效性与一致性。

\par

另一方面，C++回调机制用于处理TableGen规则难以表达的复杂语义判断与非结构化指令变换。在合并优化过程中，许多决策依赖于：

\begin{itemize}
	\item
	操作数的位级属性推理（如KnownBits分析）。
	
	\item
	目标硬件对特定操作或指令序列的实际支持能力。
	
	\item 
	变换结果在数据依赖、类型合法性和副作用方面的精细约束。
	
\end{itemize}

这类逻辑通常需要直接访问编译时分析结果并进行灵活的条件判断。因此对于每条合并规则，其核心的匹配验证与指令变换逻辑均由C++代码实现：它依据匹配条件构造新的GMIR指令序列，并在此过程中严格维护虚拟寄存器的类型一致性、数据流关系以及指令间的依赖关系，从而确保优化变换的语义正确性与架构合规性。

\par

仅采用基于TableGen的GICombiner难以准确表达复杂的语义依赖与分析驱动的优化条件；若完全采用C++回调实现，则会导致优化逻辑分散在大量手写代码中，降低规则的可读性与可维护性。基于上述考虑，本文采用TableGen负责结构化模式描述、C++回调负责语义判断与指令重写的混合设计方案，在保证合并优化表达能力的同时，有效提升了工程可维护性与扩展性。

\par

在实现层面上，合并优化规则首先以GICombineRule的形式在td文件中声明，并由TableGen自动生成对应的匹配执行器代码。随后，这些规则由Combiner框架在MachineFunction粒度上统一调度与执行，对GMIR指令流进行遍历和合并，从而在指令合法化前后逐步消除冗余指令、重构指令序列，并提升最终生成代码的执行效率。

\par

在GlobalISel框架中，指令合法化阶段不仅构成代码生成流程中的关键功能边界，同时也是优化策略划分的重要依据。由于指令在合法化前后，其类型信息、操作数形态及目标相关约束的完备程度存在显著差异，编译器在不同阶段所能实施的优化类型与优化空间也随之发生变化。基于这一特点，本文在DSP后端中将优化策略按生效阶段进行系统化划分：一类面向通用GMIR表达，主要针对语义拆分冗余消除与表达式规范化，统一在Pre-Legalize Combiner阶段实施；另一类则依赖合法化后稳定的类型与操作数信息，侧重于目标相关指令匹配与代码质量提升，在Post-Legalize Combiner阶段完成。下文将结合具体优化实例，对上述两类优化策略的设计与实现进行详细分析。


%*********************************************************************
% 3.2 合法化前优化策略
%*********************************************************************
\section{合法化前优化策略}
合法化之前，GMIR仍处于高度通用的表示阶段，指令尚未被约束为DSP架构所支持的具体形式。该阶段的优化不涉及目标指令集的具体限制，重点在于语义层面的简化与结构性重写，以减少冗余并规范表达式形态，为后续Legalizer与Instruction Selector提供更加稳定的匹配条件，同时保留足够的优化自由度，主要包括以下几类：

\begin{itemize}
	\item
	表达式合并与规范化，如消除冗余的类型扩展（G\_ZEXT(G\_ZEXT(x))）、合并重复的算术或逻辑操作，为后续指令选择创造更简洁的模式。
	
	\item
	基于语义等价的指令融合，例如将G\_MUL+G\_ADD的通用表示提前重构为更利于匹配硬件乘加指令MAC的形式。
	
	\item 
	分析驱动的优化，如利用KnownBits、CSE等分析结果进行常量折叠、冗余计算消除和条件简化。
	
\end{itemize}

由于此阶段允许暂时存在非法指令，优化变换不必立即满足目标指令集的约束，从而具备更大的自由度，能够在保持语义不变的前提下，对指令结构进行深度重构。


% 3.2.1 内存操作优化
\subsection{内存操作优化}
内存操作指令的优化是Pre-Legalize Combiner阶段中的一种典型优化，主要针对通用GMIR中高层内存操作指令所引入的函数调用冗余问题。在GlobalISel的默认实现中，G\_MEMCPY、G\_MEMMOVE等高层内存操作通常会在合法化过程中被直接降级为对标准库函数的调用。这种处理方式在保证语义正确性的同时，也为不同目标架构提供了统一的实现路径，但在实际代码生成过程中并非始终高效。

\par

在小规模内存操作场景下，函数调用本身所带来的调用约定维护、参数准备以及返回处理等额外开销，往往远大于实际内存访问指令的执行成本，从而造成明显的性能浪费。以DSP架构为例，在GlobalISel框架下以O0优化等级编译时，一次memcpy调用所生成的指令数量可达83条，其中函数本体占80条指令，额外的调用开销为3条指令。对于仅拷贝少量字节的数据而言，这样的实现方式显然并不经济。基于上述观察，本文在合法化之前引入了一种针对高层内存操作的合并优化策略：在满足一定约束条件的前提下，主动将小规模内存拷贝操作内联展开为显式的load/store指令序列，从而避免不必要的函数调用开销。

\par

将该优化放置于Pre-Legalize Combiner阶段具有明确的设计考量。一方面，此阶段的GMIR仍保持较高的抽象层次，能够完整保留内存操作的语义信息与对齐属性，便于判断是否适合进行内联展开；另一方面，在合法化之前进行转换，可以避免在后续阶段引入额外的调用指令及栈帧调整，从源头上降低指令数量与控制流复杂度，同时也有利于后续指令选择与调度优化。

\par

在DSP后端的Pre-Legalize Combiner中，本文以lowerMemcpy为代表实现了该类优化策略，其整体流程如算法\ref{alg:lower-memcpy}所示。该算法首先综合源地址与目标地址的对齐信息，确定可安全使用的内存访问粒度；随后结合拷贝长度与预设阈值，判断是否存在可行的内联展开方案。当目标地址对应非固定栈对象时，算法还会在必要情况下对栈对齐进行调整，以提升后续内存访问指令的对齐程度。在满足上述条件后，原始的G\_MEMCPY指令将被逐步替换为一组等价的load/store指令，并最终从指令流中移除。

\begin{algorithm}[htbp]
	\SetAlgoLined
	\linespread{1}\selectfont
	
	\KwIn{$MI$, $Dst$, $Src$, $Len$, $Limit$}
	\KwOut{Legalized or UnableToLegalize}
	\caption{lowerMemcpy: inline memcpy as loads/stores}
	\label{alg:lower-memcpy}
	
	$Align \leftarrow \min(DstAlign, SrcAlign)$\;
	$CanRealign \leftarrow$ IsNonFixedFrameIndex($Dst$)\;
	$(DstMMO,SrcMMO) \leftarrow$ ReadMemOperands($MI$)\;
	
	$MemOps \leftarrow$ FindMemOpTypes($Len$, $Limit$, $Align$, $CanRealign$)\;
	\If{$MemOps=\emptyset$}{
		\Return UnableToLegalize\;
	}
	
	\If{$CanRealign$}{
		$NewAlign \leftarrow$ ABIAlign($MemOps[0]$)\;
		$NewAlign \leftarrow$ ClampToStack($NewAlign$)\;
		\If{$NewAlign>Align$}{
			UpdateStackAlign($Dst$, $NewAlign$)\;
			$Align \leftarrow NewAlign$\;
		}
	}
	
	InitBuilderAt($MI$)\;
	$Off \leftarrow 0$\;
	$Rem \leftarrow Len$\;
	
	\ForEach{$Ty \in MemOps$}{
		\If{$Ty.bytes>Rem$}{
			$Off \leftarrow Off-(Ty.bytes-Rem)$\;
		}
		$LoadMMO \leftarrow$ MakeMMO($SrcMMO,Off,Ty.bytes$)\;
		$StoreMMO \leftarrow$ MakeMMO($DstMMO,Off,Ty.bytes$)\;
		$P_s \leftarrow$ PtrAt($Src,Off$)\;
		$P_d \leftarrow$ PtrAt($Dst,Off$)\;
		$V \leftarrow$ EmitLoad($Ty,P_s,LoadMMO$)\;
		EmitStore($V,P_d,StoreMMO$)\;
		$Off \leftarrow Off+Ty.bytes$\;
		$Rem \leftarrow Rem-Ty.bytes$\;
	}
	
	EraseInstr($MI$)\;
	\Return Legalized\;
\end{algorithm}


% 3.2.2 拓展截断优化
\subsection{拓展截断优化}


\subsubsection{1.冗余截断与比较指令优化}
在合法化前，编译器通常会引入形如截断+比较的冗余指令序列。这类模式通常表现为：先对一个宽位宽寄存器执行截断操作，之后再将截断结果与零进行比较。这种现象大多来源于高层IR中的类型收缩、布尔表达式转换以及通用指令的拆分策略等因素。

\par

从语义角度来看，如果被截断寄存器的高位仅由符号扩展产生，那么这些高位在逻辑上并不包含有效信息。在这种情况下，对截断后的结果进行零比较，与直接对原始宽位宽值进行零比较在语义上是等价的。基于这一结论，本节在合法化前引入了针对冗余截断+比较模式的合并优化。

\par

该优化首先利用KnownBits分析对被截断操作数进行位级信息推断，判断其高位是否完全由符号位扩展而来；若满足该条件，则说明截断操作并不会改变数值的符号与零值判定结果。此时，优化过程将原本以截断结果为操作数的比较指令，直接重写为对宽位宽操作数与零进行比较，同时移除多余的G\_TRUNC指令。一个典型的示例如代码块\ref{lst:trunc_before}和代码块\ref{lst:trunc_after}所示。

\begin{figure}[htbp]
	\centering
	\begin{minipage}[t]{0.48\linewidth}
		\captionsetup{type=lstlisting}
		\begin{lstlisting}[language=C++, caption={截断比较优化前}, label={lst:trunc_before}]
	%0:_(s64) = COPY $d0
	%1:_(s32) = G_CONSTANT i32 0
	%2:_(s32) = G_TRUNC %0:_
	%3:_(s1)  = G_ICMP slt, %1:_, %2:_
		\end{lstlisting}
	\end{minipage}\hfill
	\begin{minipage}[t]{0.48\linewidth}
		\captionsetup{type=lstlisting}
		\begin{lstlisting}[language=C++, caption={截断比较优化后}, label={lst:trunc_after}]
	%0:_(s64) = COPY $d0
	%1:_(s32) = G_CONSTANT i32 0
	%3:_(s1)  = G_ICMP slt, %0:_, %1:_
			
		\end{lstlisting}
	\end{minipage}
\end{figure}

在经过这一优化后，编译器不仅减少了一条通用中间指令和对应的虚拟寄存器定义，还简化了数据流依赖关系，使比较操作更贴近硬件语义。在DSP架构下，该优化有助于后续指令选择阶段更直接地匹配硬件比较指令与条件跳转指令，从而提升代码密度并降低执行延迟。


\subsubsection{2.拓展下推优化}
在GMIR中，算术指令往往作用于经过符号扩展G\_SEXT或零扩展G\_ZEXT后的操作数。这种形式虽然在语义上是正确的，但在实际工程中会引入多余的扩展指令，导致指令数量的增加及后续目标指令匹配与融合的成功率的降低。为此，本文引入一种EPO（Extension Pushing Optimization，扩展下推优化），优化通过重写算术运算与扩展指令的组合形式，将算术操作下推至扩展之前，从而获得更加规范、紧凑的中间表示。

\par

考虑如下典型模式：

\[
\operatorname{add}(\operatorname{zext}\, x,\ \operatorname{zext}\, y)
\]

该形式在GMIR中表现为两个扩展指令后接一条算术指令。由于DSP指令集中包含带扩展的算术指令，允许在较小位宽上直接完成算术运算，再对结果进行一次统一扩展。因此，将算术操作推到扩展之前能够减少冗余的扩展指令数量，降低指令条数。除此之外，还能形成更规范的IR结构，提升指令选择阶段的模式匹配成功率。优化针对ADD和SUB指令，适用于零扩展与符号扩展两种情形，其核心重写规则可概括为：

\[
\operatorname{op}\bigl(\operatorname{ext}\, x,\ \operatorname{ext}\, y\bigr)
\;\Rightarrow\;
\operatorname{ext}\!\bigl(\operatorname{op}(x, y)\bigr)
\]

其中，op表示算术操作ADD或SUB，ext表示扩展操作ZEXT或SEXT。值得注意的是，在变换过程中必须保证扩展类型的一致性，并在符号扩展场景下正确维护符号语义。在Combiner中，该优化通过参数化的TableGen规则进行描述。其核心定义代码块\ref{lst:epo_tb}所示。

\begin{lstlisting}[language=C++, caption={EPO的TableGen规则}, label={lst:epo_tb}]
	class epo_base<Instruction opcode, Instruction extOpcode>
			: GICombineRule <
		(defs root:$root),
		(match (extOpcode $ext1, $src1):$ExtMI, (extOpcode $ext2, $src2),
			(opcode $dst, $ext1, $ext2):$root,
			[{ return matchEPO(*${root}, MRI, $dst, $src1, $src2); }]),
		(apply [{
			applyEPO(*${root}, MRI, B,
			${ExtMI}->getOpcode() == TargetOpcode::G_SEXT, $dst, $src1, $src2);
		}])
	>;
\end{lstlisting}

该规则通过模板参数抽象了算术操作类型ADD/SUB以及扩展类型ZEXT/SEXT，从而避免重复定义多条相似规则。在匹配阶段，规则要求两个操作数均来源于相同类型的扩展指令，并由指定的算术指令使用；在应用阶段，根据扩展类型生成新的算术指令，并在必要时重新插入对应的扩展操作。该优化在语义上是安全的，其正确性基于如下事实：

\begin{itemize}
	\item 对于零扩展ZEXT，扩展前后的值在无符号算术意义下保持一致.
	
	\item 对于符号扩展SEXT，在保证算术运算不发生未定义行为的前提下，先运算后扩展与先扩展后运算在数学语义上等价.
	
	\item 优化过程中不改变数据依赖关系，仅调整指令组合方式。
	
\end{itemize}

EPO属于一种IR规范化类优化，并不以直接降低程序的运行时间为目标，而是通过统一和规整中间表示结构，为后续目标相关优化与指令选择提供更优的输入形式。在DSP架构上，该优化提升了复合指令匹配的成功率，从而在代码生成阶段间接减少最终生成指令的数量。


%*********************************************************************
% 3.3 合法化后优化策略
%*********************************************************************
\section{合法化后优化策略}
合法化之后，所有GMIR指令均已被转换为目标架构支持的合法形式，指令的类型、操作数位宽及内存访问方式均受到严格约束。此时优化的重点转向目标相关的性能优化与代码质量提升，主要包括以下几类：

\begin{itemize}
	\item
	目标指令匹配与替换优化，如将合法化后形成的指令序列进一步合并为DSP架构提供的伪指令或复合指令，以提升执行效率。
	
	\item
	指令调度友好的局部合并，如通过消除多余拷贝、简化寄存器间的数据搬移来降低寄存器压力，为后续寄存器分配与指令调度创造更优条件。
	
	\item 
	面向代码密度和执行效率的微优化，如立即数折叠、访存地址计算合并以及针对硬件流水线特性的局部重写。
	
\end{itemize}

由于合法化后指令已经紧密贴合目标架构，这一阶段的优化虽在语义变换自由度上受限，但能够更直接地转化为实际的性能收益。


% 3.3.1 立即数装载优化
\subsection{立即数装载优化}
在指令选择阶段，G\_CONSTANT和G\_FCONSTANT需要被转化为目标指令集可执行的装载立即数序列。对于DSP后端而言，指令采用固定32位编码格式。由于指令由操作码与操作数组成，且立即数字段的编码宽度通常不超过16位，单条指令中可用于表示立即数的位数受到严格限制，因此32位常量一般无法通过单条指令直接完成装载。因此，对于32位立即数，若不加区分地统一采用长立即数装载伪指令MOVI，则会引入额外的指令开销。

\par

针对上述问题，本文结合DSP平台的ISA特性，在全局指令选择阶段对立即数装载过程进行定制化优化。核心思想是根据常量的位型特征对立即数进行分类，并优先选择编码长度更短、执行开销更低的装载形式，从而在保证语义正确性的前提下减少冗余指令。以32位立即数为例，可将其划分为以下三类情况。


\subsubsection{1.立即数的高16位全0}
当立即数的高16位全为0时，立即数可视为一个零扩展的16位无符号数，只需要装载低16位即可。由于硬件指令集的限制，即使立即数的高16位全为0，也无法省略对高位赋值的操作。为此本节提出一种基于零寄存器的装载策略，通过设置一个零寄存器并将零寄存器作为源操作数，结合立即数加法指令来完成立即数的加载，从而避免了使用通用的长立即数装载伪指令，如代码块\ref{lst:imm_con1_before}和代码块\ref{lst:imm_con1_after}所示。

\begin{figure}[htbp]
	\centering
	\begin{minipage}[t]{0.48\linewidth}
		\captionsetup{type=lstlisting}
		\begin{lstlisting}[language=C++, caption={CSE优化前}, label={lst:imm_con1_before}]
			MOVIGH GR2 0x0;
			MOVIGL GR2 0x1;
		\end{lstlisting}
	\end{minipage}\hfill
	\begin{minipage}[t]{0.48\linewidth}
		\captionsetup{type=lstlisting}
		\begin{lstlisting}[language=C++, caption={CSE优化后}, label={lst:imm_con1_after}]
			ADDI ZERO 0x1;
			
		\end{lstlisting}
	\end{minipage}
\end{figure}


\subsubsection{2.立即数的高17位全1}
当立即数的高17位全为1，即为可用16位有符号立即数表示的常量时，可以利用MOVIGLX指令来实现将一个16位的有符号立即数进行符号位扩展至32bit后复制到rd中。于是当常量满足Imm∈\([-2^{15},\, 2^{15}-1]\)时，可将imm16符号扩展到32位写入Rd，如代码块\ref{lst:imm_con2_before}和代码块\ref{lst:imm_con2_after}所示。

\begin{figure}[htbp]
	\centering
	\begin{minipage}[t]{0.48\linewidth}
		\captionsetup{type=lstlisting}
		\begin{lstlisting}[language=C++, caption={CSE优化前}, label={lst:imm_con2_before}]
			MOVIGH GR2 0xFFFF;
			MOVIGL GR2 0xF123;
		\end{lstlisting}
	\end{minipage}\hfill
	\begin{minipage}[t]{0.48\linewidth}
		\captionsetup{type=lstlisting}
		\begin{lstlisting}[language=C++, caption={CSE优化后}, label={lst:imm_con2_after}]
			MOVIGLX GR2 0xF123;
			
		\end{lstlisting}
	\end{minipage}
\end{figure}


\subsubsection{3.其他情况}
对于不满足上述情况的立即数，由于无法通过单条指令完成装载，只能使用伪指令拓展的长立即数装载方式，伪指令会在后续阶段展开为MOVIGH和MOVIGL两条机器指令。其中MOVIGH装载立即数的高16位到寄存器高半区，而MOVIGL装载立即数的低16位到寄存器低半区。

\par

上述优化策略在指令选择阶段完成对立即数形式的判定与映射，避免了在后续低层次优化中对立即数序列进行二次修正。通过对立即数位型的精细化分类，该优化能在不增加指令选择复杂度的前提下，有效减少冗余指令的生成，从而为后续寄存器分配与指令调度提供了更紧凑的输入形式。该优化能够在常量使用频繁的程序中显著降低代码体积并提高整体执行效率。


% 3.2.2 乘法优化
\subsection{乘法优化}
乘法的硬件实现通常具有较高的延迟与开销，因此对于乘数为编译期常量的整数乘法，直接生成乘法指令往往不是最优选择。事实上，许多常量乘法在算术上可以等价地分解为移位与加减操作，从而以更低的执行成本完成相同计算。基于这一考虑，本文在合法化后阶段对G\_MUL指令引入常量乘法强度削减优化。当乘数为满足特定形式的编译期常量时，编译器将原始乘法操作替换为由移位G\_SHL与加法G\_ADD或减法G\_SUB组成的等价指令序列。


\subsubsection{1.理论基础}
从算术等价关系来看，若常量 $C$ 满足以下形式之一：
\begin{equation}
	C = 2^n \pm 1
\end{equation}
或
\begin{equation}
	C = (2^n \pm 1) \times 2^m
\end{equation}

则乘法运算可以通过移位与加减运算等价实现：
\begin{equation}
	x \times (2^n + 1) = (x \ll n) + x
\end{equation}

\begin{equation}
	x \times (2^n - 1) = (x \ll n) - x
\end{equation}

\begin{equation}
	x \times \big((2^n \pm 1) \times 2^m\big)
	= \big((x \ll n) \pm x\big) \ll m
\end{equation}

这些变换在保持程序语义完全一致的前提下，能够显著降低指令执行代价，并减少对乘法硬件单元的依赖。


\subsubsection{2.匹配阶段}
在匹配阶段，优化逻辑以G\_MUL指令为目标，对其操作数及常量特征进行系统分析，整体匹配流程如算法\ref{alg:const_mul_strength_reduction}所示。具体而言，该阶段主要包括以下三个步骤：

\begin{enumerate}
	\item
	常量识别：通过常量传播与等价查询机制，判断右操作数是否为编译期常量，若满足条件，则获取乘法右操作数的常量值。
	
	\item
	位型分析：利用位运算分析常量的二进制结构，判断其是否满足上述形式。
	
	\item 
	约束检查：为避免干扰后续指令融合或破坏已存在的扩展语义，匹配阶段还会检查源操作数是否仅被当前指令使用以及排除可能影响符号扩展、零扩展或寄存器重用的场景。
	
\end{enumerate}

\begin{algorithm}[htbp]
	\SetAlgoLined
	\linespread{1}\selectfont
	
	\KwIn{MachineInstr $MI$}
	\KwOut{InstructionMapping or fail}
	\caption{Constant-Multiply Strength Reduction}
	\label{alg:const_mul_strength_reduction}
	
	\If{$opcode(MI) \neq G\_MUL$}{
		\Return fail\;
	}
	\If{RHS is not an integer constant}{
		\Return fail\;
	}
	
	$C \leftarrow sext(const(RHS))$\;
	$TZ \leftarrow countr\_zero(C)$\;
	$C' \leftarrow ashr(C, TZ)$\;
	
	\eIf{$C' > 0$}{
		\eIf{$(C' - 1)$ is power of two}{
			Rewrite as $(x \ll \log_2(C'-1)) + x$\;
		}{
			\If{$(C' + 1)$ is power of two}{
				Rewrite as $(x \ll \log_2(C'+1)) - x$\;
			}
			\Else{\Return fail\;}
		}
	}{
		\eIf{$(-C' + 1)$ is power of two}{
			Rewrite as $x - (x \ll \log_2(-C'+1))$\;
		}{
			\If{$(-C' - 1)$ is power of two}{
				Rewrite as $-( (x \ll \log_2(-C'-1)) + x )$\;
			}
			\Else{\Return fail\;}
		}
	}
	
	\Return success\;
\end{algorithm}


\subsubsection{3.重写阶段}
在重写阶段，编译器根据匹配到的常量形式，生成对应的移位与加减指令序列，并替换原有的G\_MUL指令。重写操作后，原本需多个周期完成的乘法操作被转换为仅由低延迟移位与加减指令组成的序列，在保持计算结果精确不变的前提下，显著降低了指令的执行开销，并减少了对专用乘法硬件单元的占用。


%*********************************************************************
% 3.4 本章小结
%*********************************************************************
\section{本章小结}
本章针对DSP架构下GlobalISel的性能问题，系统分析并设计了多种全局指令选择优化策略。其中针对指令选择过程中产生的冗余指令与效率问题，本章针对DSP架构引入并实现了CSE、KnownBits Analysis以及Combiner等优化技术，用于减少重复计算、简化指令序列并提升硬件资源利用率，并对其理论基础与在不同阶段的应用方式进行了详细的分析。

\par

本章提出的优化策略依据其对目标架构的依赖程度，可划分为合法化前与合法化后两个阶段。在具体技术手段上，通过公共子表达式消除减少冗余计算与寄存器占用，借助已知位分析提供比特级信息以支持常量传播与指令简化，并利用指令合并优化重构代码序列以增强执行密度。进一步地，结合DSP架构特性，本章引入了针对性的立即数装载优化与乘法相关优化，有效增强了指令生成过程对硬件约束的适配能力，从而在保障语义正确性的同时，提升了整体执行性能。
