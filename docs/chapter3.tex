\chapter{全局指令选择优化策略}


%*********************************************************************
% 3.1 优化策略的分析与设计
%*********************************************************************
\section{优化策略的分析与设计}
在经过GMIR生成、指令合法化、寄存器组选择以及机器指令选择4个核心Pass处理之后，原始的LLVM IR已经成功被转换成MIR。尽管这一流程已实现指令选择阶段的目标，但是生成的代码质量相比于SelectionDAGISel较差。代码质量的差距主要体现在指令数量冗余、硬件专用指令利用率低以及寄存器资源分配不够高效等方面。

\par

为了缩小与SelectionDAGISel在代码质量上的差距，本文引入了包括CSE（Common Subexpression Elimination, 公共子表达式消除）、已知比特分析（KnownBits Analysis）以及合并优化（Combiner）等多项优化技术。这些优化策略通过降低指令冗余、精确推断操作数的已知状态并简化表达式，从而显著提升了生成代码的性能。


% 3.1.1 优化的理论依据
\subsection{优化的理论依据}
程序在编译过程中，尤其是在从高级的LLVM IR向低级的目标相关指令转换时，会不可避免地引入大量的冗余。这些冗余体现为计算冗余（公共子表达式重复计算）、数据冗余（多余的拷贝指令）和表示冗余（复杂的指令序列可用更高效的指令替代）。优化的根本任务就是系统性地识别并消除这些冗余，在保证程序语义不变的前提下，提高生成代码的执行效率、代码密度及硬件利用率。

\par

GlobalISel与SelectionDAGISel的代码质量差距，本质上源于两者设计目标与实现路径的差异。SelectionDAGISel针对特定架构定制化设计，其核心表示为SelectionDAG，天然具备对局部计算图进行重写与合并的能力；而GlobalISel为适配不同架构的指令集特性，采用通用中间表示+模块化Pass的设计，导致代码生成过程中不可避免地引入冗余，具体根源可归结为三点：

\begin{enumerate}
	\item
	通用化转换带来的语义冗余：为保证跨架构语义的一致性，GlobalISel在LLVM IR向GMIR转换及指令合法化阶段，会将复杂运算拆分为一系列简单的原子指令。例如，将DSP架构的乘加运算（MAC）拆分为乘法与加法指令，将宽类型数据访问拆分为多次窄类型加载/存储指令，这种拆分虽保证了语义正确性，却引入了大量指令级冗余。
	
	\item
	寄存器组选择的局部性局限：寄存器组选择阶段以基本块为粒度分配寄存器组，未充分考虑函数级的全局数据流依赖，易导致跨基本块的频繁跨组数据复制。例如，循环变量在不同基本块中被分配到不同寄存器组，需通过专用复制指令完成数据迁移，显著增加了执行延迟。
	
	\item 
	硬件特性适配的滞后性：机器指令选择阶段的主要目标是完成从通用GMIR到目标指令的语义映射，其默认策略往往采用局部的、一对一的映射。由于复杂指令模式的识别被推迟到较晚阶段，编译器往往难以及时捕捉跨多条GMIR指令的复合语义，这会导致硬件中专用功能单元的性能潜力无法被充分挖掘。
	
\end{enumerate}

从理论上来看，高效优化的前提是精确可靠的程序分析。数据流分析（如CSE所依赖的可用表达式分析）揭示了值是如何在程序中产生和传播的；而信息流分析（如KnownBits分析）则从位级推断值的可能范围。这些分析为优化变换提供了可行性证明和安全保障。

\par

从实际上来看，DSP处理器的指令集包含大量面向特定计算模式设计的复合指令，如乘加、向量加载/存储及多数据并行运算指令。优化需要具备对指令模式的识别能力，能够在合适的阶段将通用操作序列映射为高度优化的硬件指令。只有在分析与变换机制的共同支撑下，编译器才能在保证通用性的同时，生成兼具高性能与高效率的目标代码。


% 3.1.2 关键优化技术分析
\subsection{关键优化技术分析}
1.公共子表达式消除

公共子表达式消除是一种经典的编译优化技术，其核心思想是消除程序中重复计算相同表达式的冗余操作，避免冗余的运算操作与寄存器占用，从而精简代码体积、降低执行延迟。在指令选择阶段，如果一个表达式的值已经被计算过，并且其操作数未被重新定义，则可以复用之前的计算结果，避免重复计算，从而减少冗余指令的生成。对于下例，在优化前b+c被计算了3次，优化后只需要计算1次。


\begin{table}[htbp]
	\centering
	\caption{公共子表达式消除示例}
	\label{tab:cse-example}
	\renewcommand{\arraystretch}{1.0}
	\begin{tabular}{|p{0.45\linewidth}|p{0.45\linewidth}|}
		\hline
		\begin{minipage}[t]{\linewidth}
			\lstset{
				basicstyle=\ttfamily\footnotesize,
				frame=none,
				numbers=none
			}
			\begin{lstlisting}
				// 优化前
				a = b + c;
				d = b + c;
				e = b + c * 2;
				f = (b + c) * 3;
			\end{lstlisting}
		\end{minipage}
		&
		\begin{minipage}[t]{\linewidth}
			\lstset{
				basicstyle=\ttfamily\footnotesize,
				frame=none,
				numbers=none
			}
			\begin{lstlisting}
				// 优化后
				temp = b + c;
				a = temp;
				d = temp;
				e = b + c * 2;
				f = temp * 3;
			\end{lstlisting}
		\end{minipage}
		\\
		\hline
	\end{tabular}
\end{table}

与传统的CSE不同，GlobalISel采用了持续CSE（Continuous CSE）策略。这种策略通过在指令创建时即时检查是否存在等价的表达式，从而消除不必要的冗余计算。持续CSE能够在基本块内高效工作，避免了全函数扫描的代价高昂性。这种局部的优化策略能够大幅提升编译效率，同时保持优化效果。

\par

CSE不仅能够消除冗余指令，为后续优化创造更多的机会，而且还能减少寄存器的使用。在指令合并优化阶段，复用公共子表达式的计算结果往往能够暴露出更复杂的合并模式。例如，如果两个计算共享相同的子表达式，合并优化可能通过识别这些冗余的计算来进一步简化指令序列，提升代码执行效率。

2.已知比特分析

已知比特分析是一种静态推断寄存器各位已知状态的技术，主要用于优化常量传播和指令简化，通过跟踪每个位的已知状态来帮助优化器做决策。核心目标是在不引入额外运行时开销的前提下，尽可能提前获取寄存器值的精确信息，从而辅助常量传播、指令简化以及后续的合并优化决策。该分析通过对寄存器中必然为0或必然为1的比特位进行建模，为优化器提供细粒度的位级语义信息。

\par

已知比特分析以寄存器的初始比特状态作为分析起点。这些初始信息可能来源于多种途径，例如：函数参数在ABI层面的位宽约束、全局变量的初始化值、字面量常量的比特分布，或前序优化阶段已推导出的比特属性。随后，分析沿着指令的数据流依赖关系，对寄存器的比特信息进行逐指令传播与更新。

\par

在实现层面，每个寄存器通常维护两个并行的比特掩码：KnownZeros和KnownOnes。其中，KnownZeros标记所有必然为0的比特位，KnownOnes标记所有必然为1的比特位，其余未被标记的比特则视为未知。随着指令流的推进，这两个掩码会根据指令语义持续更新，从而逐步积累更精确的寄存器状态信息。下面的示例展示了已知比特分析在简单算术与逻辑运算中的效果：

\lstset{language=c++}
\begin{lstlisting}
	int test(int a) {
		int b = a & 0xFFFF;   // 低16位保留，高16位必为0
		int c = b | 0x10000;  // 第17位必为1
		return c;
	}
	// b: KnownZeros = 0xFFFF0000, KnownOnes = 0x00000000
	// c: KnownZeros = 0xFFFE0000, KnownOnes = 0x00010000
\end{lstlisting}

通过上述分析结果，编译器能够准确获知变量b的高16位始终为0，而变量c的第17位必然为1。这类信息在后续优化阶段具有重要价值：一方面可用于消除冗余的掩码、扩展或比较指令；另一方面也为指令合并与目标指令匹配提供更精确的语义依据，从而生成更紧凑、高效的机器代码。

3.合并优化

在GlobalISel框架中，合并优化是提升代码质量的核心手段之一。合并优化的主要目标是通过删除冗余的指令、简化表达式、合并常见的操作模式来减少代码的规模，并提高执行效率。它能充分利用目标架构的复杂指令，减少不必要的操作和存储器访问。

\par

合并优化本质上可以视为窥孔优化（Peephole Optimization）的推广形式，但其作用范围已不再局限于固定长度的局部指令窗口，而是能够在更大的指令序列尺度上进行模式识别与重写，甚至支持跨多条指令、跨基本块的优化决策。该优化策略的理论基础主要来源于以下几个方面的观察。

\par

首先，在低级代码生成过程中，编译器往往会为了表达中间计算结果而生成一系列结构简单但语义相关的指令序列，这类指令在指令级层面存在显著冗余。若目标架构提供语义等价但更为复杂的指令形式，这些冗余序列通常可以被单条高效指令所替代，从而减少指令数量和中间结果的产生。

\par

其次，指令之间普遍存在较强的数据流局部性。相邻或近邻指令往往共享操作数或存在直接的定义–使用关系，这为编译器识别可合并的操作模式提供了天然条件，使得合并优化能够在保持语义正确性的前提下，对指令序列进行整体重构。

\par

最后，现代处理器指令集日益丰富，广泛支持乘加（MAC）、融合算术、向量化等复合指令形式。合并优化正是连接通用中间表示与这些复杂目标指令之间的关键桥梁，其效果直接决定了编译器对目标架构计算能力的利用程度。

\par

在所有这些优化中，合并优化承担着将优化机会最终转化为性能收益的核心职责。其主要目标是通过删除冗余指令、简化表达式、合并常见的操作模式来减少代码规模，并提高执行效率。例如，它将两个连续的零扩展指令G\_ZEXT(G\_ZEXT(x))合并为单一的G\_ZEXT(x)，或者将独立的乘法（G\_MUL）和加法（G\_ADD）指令融合为一条高效的乘加（MAC）指令。正是通过这种深度的指令融合，才能充分利用目标架构的复杂指令，减少不必要的操作和存储器访问。


% 3.1.3 基于DSP的优化设计
\subsection{基于DSP的优化设计}
单一的优化策略通常难以应对复杂的代码生成需求，因此需要一个多策略协同的优化体系。本章将深入分析以合并优化为核心，并辅以公共子表达式消除、合法化策略以及窥孔优化等多种策略的全局指令选择优化方法。由于公共子表达式消除属于通用优化且已经在框架中实现，只需要调用相应的接口即可，下文主要针对合并优化。

\par

为在GlobalISel框架下实现高效、可扩展的DSP优化，本文采用基于TableGen的 GICombiner描述机制与C++回调逻辑相结合的实现路径。该设计充分利用了两种机制在表达能力与工程组织上的互补优势，实现了合并优化规则的高效描述与可靠执行。

\par

具体而言，基于TableGen的GICombiner主要用于描述可合并指令的结构化模式。通过在td文件中定义GICombineRule，可以以声明式的方式刻画指令之间的拓扑关系、操作码组合以及操作数约束条件。TableGen在编译阶段自动生成对应的匹配执行器代码（ 如合法化前的DSPGenPreLegalizeGICombiner.inc），从而避免了手工编写复杂的匹配逻辑，并保证了规则匹配过程的高效性与一致性。

\par

另一方面，C++回调机制则用于承担TableGen难以表达的复杂语义判断与指令重构工作。在合并过程中，许多优化决策依赖于位级信息推断（如KnownBits分析）、子目标特性（如DSP硬件功能单元支持情况）、以及对合法性与数据依赖关系的精细控制。这类逻辑通常需要借助C++代码访问分析结果并进行条件判断。因此，在每条合并规则中，具体的匹配判定与变换执行均由C++实现，用于根据匹配结果构造新的GMIR指令序列，并维护虚拟寄存器类型、数据流关系及指令依赖的一致性。

\par

仅采用基于TableGen的GICombiner难以准确表达复杂的语义依赖与分析驱动的优化条件，而完全依赖C++回调又会导致合并规则分散在大量手写代码中，降低规则的可读性与可维护性。基于上述考虑，本文采用TableGen负责结构化模式描述、C++回调负责语义判断与指令重写的混合设计方案，在保证合并优化表达能力的同时，有效提升了工程可维护性与扩展性。

\par

在实现层面，合并优化规则首先以GICombineRule的形式在td文件中声明，并由TableGen自动生成对应的匹配执行器代码。随后，这些规则由Combiner框架在MachineFunction粒度上统一调度与执行，对GMIR指令流进行遍历和合并，从而在指令合法化前后逐步消除冗余指令、重构指令序列，并提升最终生成代码的执行效率。

\par

在GlobalISel框架中，指令合法化阶段不仅是代码生成流程中的功能性边界，同时也是优化策略划分的重要分水岭。根据指令是否合法化，编译器能够执行的优化类型和优化空间存在显著差异，因此有必要分别在合法化前后引入针对性的优化策略。


%*********************************************************************
% 3.2 优化策略的实现
%*********************************************************************
\section{优化策略的实现}