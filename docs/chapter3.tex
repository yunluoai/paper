\chapter{面向DSP的全局指令选择优化}


%*********************************************************************
% 3.1 优化策略分析与设计
%*********************************************************************
\section{优化策略分析与设计}
在经过GMIR生成、指令合法化、寄存器组选择以及机器指令选择4个核心Pass处理之后，原始的LLVM IR已经成功被转换成MIR。尽管这一流程已实现指令选择阶段的目标，但是生成的代码质量相比于SelectionDAGISel较差。代码质量的差距主要体现在指令数量冗余、硬件专用指令利用率低以及寄存器资源分配不够高效等方面。

\par

为了缩小与SelectionDAGISel在代码质量上的差距，本文引入了包括CSE（Common Subexpression Elimination, 公共子表达式消除）、已知比特分析（KnownBits Analysis）以及合并优化（Combiner）等多项优化技术。这些优化策略通过降低指令冗余、精确推断操作数的已知状态并简化表达式，从而显著提升了生成代码的性能。


% 3.1.1 优化策略理论依据
\subsection{优化策略理论依据}
程序在编译过程中，尤其是在从高级的LLVM IR向低级的目标相关指令转换时，会不可避免地引入大量的冗余。这些冗余体现为计算冗余（公共子表达式重复计算）、数据冗余（多余的拷贝指令）和表示冗余（复杂的指令序列可用更高效的指令替代）。优化的根本任务就是系统性地识别并消除这些冗余，在保证程序语义不变的前提下，提高生成代码的执行效率、代码密度及硬件利用率。

\par

GlobalISel与SelectionDAGISel的代码质量差距，本质上源于两者设计目标与实现路径的差异。SelectionDAGISel针对特定架构定制化设计，其核心表示为SelectionDAG，天然具备对局部计算图进行重写与合并的能力；而GlobalISel为适配不同架构的指令集特性，采用通用中间表示+模块化Pass的设计，导致代码生成过程中不可避免地引入冗余，具体根源可归结为三点：

\begin{enumerate}
	\item
	通用化转换带来的语义冗余：为保证跨架构语义的一致性，GlobalISel在LLVM IR向GMIR转换及指令合法化阶段，会将复杂运算拆分为一系列简单的原子指令。例如，将DSP架构的乘加运算（MAC）拆分为乘法与加法指令，将宽类型数据访问拆分为多次窄类型加载/存储指令，这种拆分虽保证了语义正确性，却引入了大量指令级冗余。
	
	\item
	寄存器组选择的局部性局限：寄存器组选择阶段以基本块为粒度分配寄存器组，未充分考虑函数级的全局数据流依赖，易导致跨基本块的频繁跨组数据复制。例如，循环变量在不同基本块中被分配到不同寄存器组，需通过专用复制指令完成数据迁移，显著增加了执行延迟。
	
	\item 
	硬件特性适配的滞后性：机器指令选择阶段的主要目标是完成从通用GMIR到目标指令的语义映射，其默认策略往往采用局部的、一对一的映射。由于复杂指令模式的识别被推迟到较晚阶段，编译器往往难以及时捕捉跨多条GMIR指令的复合语义，这会导致硬件中专用功能单元的性能潜力无法被充分挖掘。
	
\end{enumerate}

从理论上来看，高效优化的前提是精确可靠的程序分析。数据流分析（如CSE所依赖的可用表达式分析）揭示了值是如何在程序中产生和传播的；而信息流分析（如KnownBits分析）则从位级推断值的可能范围。这些分析为优化变换提供了可行性证明和安全保障。

\par

从实际上来看，DSP处理器的指令集包含大量面向特定计算模式设计的复合指令，如乘加、向量加载/存储及多数据并行运算指令。优化需要具备对指令模式的识别能力，能够在合适的阶段将通用操作序列映射为高度优化的硬件指令。只有在分析与变换机制的共同支撑下，编译器才能在保证通用性的同时，生成兼具高性能与高效率的目标代码。


% 3.1.2 关键优化技术分析
\subsection{关键优化技术分析}
1.公共子表达式消除

公共子表达式消除是一种经典的编译优化技术，其核心思想是消除程序中重复计算相同表达式的冗余操作，避免冗余的运算操作与寄存器占用，从而精简代码体积、降低执行延迟。在指令选择阶段，如果一个表达式的值已经被计算过，并且其操作数未被重新定义，则可以复用之前的计算结果，避免重复计算，从而减少冗余指令的生成。如下表\ref{tab:cse-example}所示，该样例在优化前b+c被计算了3次，优化后只需要计算1次。

\noindent
\setlength{\tabcolsep}{0pt}
\renewcommand{\arraystretch}{1.0}

\begin{table}[htbp]
	\centering
	\caption{公共子表达式消除优化前后代码示例}
	\label{tab:cse-example}
	\renewcommand{\arraystretch}{1.0}
	\lstset{
		basicstyle=\ttfamily\footnotesize,
		frame=none,
		numbers=none
	}
	\begin{tabular}{|p{0.48\linewidth}|p{0.48\linewidth}|}
		\hline
		\begin{minipage}[t]{\linewidth}

			\begin{lstlisting}
				// 优化前
				a = b + c;
				d = b + c;
				e = b + c * 2;
				f = (b + c) * 3;
			\end{lstlisting}
		\end{minipage}
		&
		\begin{minipage}[t]{\linewidth}
			\begin{lstlisting}
				// 优化后
				temp = b + c;
				a = temp;
				d = temp;
				e = b + c * 2;
				f = temp * 3;
			\end{lstlisting}
		\end{minipage}
		\\
		\hline
	\end{tabular}
\end{table}

与传统的CSE不同，GlobalISel采用了持续CSE（Continuous CSE）策略。这种策略通过在指令创建时即时检查是否存在等价的表达式，从而消除不必要的冗余计算。持续CSE能够在基本块内高效工作，避免了全函数扫描的代价高昂性。这种局部的优化策略能够大幅提升编译效率，同时保持优化效果。

\par

CSE不仅能够消除冗余指令，为后续优化创造更多的机会，而且还能减少寄存器的使用。在指令合并优化阶段，复用公共子表达式的计算结果往往能够暴露出更复杂的合并模式。例如，如果两个计算共享相同的子表达式，合并优化可能通过识别这些冗余的计算来进一步简化指令序列，提升代码执行效率。

2.已知比特分析

已知比特分析是一种静态推断寄存器各位已知状态的技术，主要用于优化常量传播和指令简化，通过跟踪每个位的已知状态来帮助优化器做决策。核心目标是在不引入额外运行时开销的前提下，尽可能提前获取寄存器值的精确信息，从而辅助常量传播、指令简化以及后续的合并优化决策。该分析通过对寄存器中必然为0或必然为1的比特位进行建模，为优化器提供细粒度的位级语义信息。

\par

已知比特分析以寄存器的初始比特状态作为分析起点。这些初始信息可能来源于多种途径，例如：函数参数在ABI层面的位宽约束、全局变量的初始化值、字面量常量的比特分布，或前序优化阶段已推导出的比特属性。随后，分析沿着指令的数据流依赖关系，对寄存器的比特信息进行逐指令传播与更新。

\par

在实现层面，每个寄存器通常维护两个并行的比特掩码：KnownZeros和KnownOnes。其中，KnownZeros标记所有必然为0的比特位，KnownOnes标记所有必然为1的比特位，其余未被标记的比特则视为未知。随着指令流的推进，这两个掩码会根据指令语义持续更新，从而逐步积累更精确的寄存器状态信息。下面的示例展示了已知比特分析在简单算术与逻辑运算中的效果：

\lstset{language=c++}
\begin{lstlisting}
	int test(int a) {
		int b = a & 0xFFFF;   // 低16位保留，高16位必为0
		int c = b | 0x10000;  // 第17位必为1
		return c;
	}
	// b: KnownZeros = 0xFFFF0000, KnownOnes = 0x00000000
	// c: KnownZeros = 0xFFFE0000, KnownOnes = 0x00010000
\end{lstlisting}

通过上述分析结果，编译器能够准确获知变量b的高16位始终为0，而变量c的第17位必然为1。这类信息在后续优化阶段具有重要价值：一方面可用于消除冗余的掩码、扩展或比较指令；另一方面也为指令合并与目标指令匹配提供更精确的语义依据，从而生成更紧凑、高效的机器代码。

3.合并优化

在GlobalISel框架中，合并优化是提升代码质量的核心手段之一。合并优化的主要目标是通过删除冗余的指令、简化表达式、合并常见的操作模式来减少代码的规模，并提高执行效率。它能充分利用目标架构的复杂指令，减少不必要的操作和存储器访问。

\par

合并优化本质上可以视为窥孔优化（Peephole Optimization）的推广形式，但其作用范围已不再局限于固定长度的局部指令窗口，而是能够在更大的指令序列尺度上进行模式识别与重写，甚至支持跨多条指令、跨基本块的优化决策。该优化策略的理论基础主要来源于以下几个方面的观察。

\par

首先，在低级代码生成过程中，编译器往往会为了表达中间计算结果而生成一系列结构简单但语义相关的指令序列，这类指令在指令级层面存在显著冗余。若目标架构提供语义等价但更为复杂的指令形式，这些冗余序列通常可以被单条高效指令所替代，从而减少指令数量和中间结果的产生。

\par

其次，指令之间普遍存在较强的数据流局部性。相邻或近邻指令往往共享操作数或存在直接的定义–使用关系，这为编译器识别可合并的操作模式提供了天然条件，使得合并优化能够在保持语义正确性的前提下，对指令序列进行整体重构。

\par

最后，现代处理器指令集日益丰富，广泛支持乘加（MAC）、融合算术、向量化等复合指令形式。合并优化正是连接通用中间表示与这些复杂目标指令之间的关键桥梁，其效果直接决定了编译器对目标架构计算能力的利用程度。

\par

在所有这些优化中，合并优化承担着将优化机会最终转化为性能收益的核心职责。其主要目标是通过删除冗余指令、简化表达式、合并常见的操作模式来减少代码规模，并提高执行效率。例如，它将两个连续的零扩展指令G\_ZEXT(G\_ZEXT(x))合并为单一的G\_ZEXT(x)，或者将独立的乘法（G\_MUL）和加法（G\_ADD）指令融合为一条高效的乘加（MAC）指令。正是通过这种深度的指令融合，才能充分利用目标架构的复杂指令，减少不必要的操作和存储器访问。


% 3.1.3 面向DSP的优化设计
\subsection{面向DSP的优化设计}
单一的优化策略通常难以应对复杂的代码生成需求，因此需要一个多策略协同的优化体系。本章将深入分析以合并优化为核心，并辅以公共子表达式消除、合法化策略以及窥孔优化等多种策略的全局指令选择优化方法。由于公共子表达式消除属于通用优化且已经在框架中实现，只需要调用相应的接口即可，下文主要针对合并优化。

\par

为在GlobalISel框架下实现高效、可扩展的DSP优化，本文采用基于TableGen的 GICombiner描述机制与C++回调逻辑相结合的实现路径。该设计充分利用了两种机制在表达能力与工程组织上的互补优势，实现了合并优化规则的高效描述与可靠执行。

\par

具体而言，基于TableGen的GICombiner主要用于描述可合并指令的结构化模式。通过在td文件中定义GICombineRule，可以以声明式的方式刻画指令之间的拓扑关系、操作码组合以及操作数约束条件。TableGen在编译阶段自动生成对应的匹配执行器代码（ 如合法化前的DSPGenPreLegalizeGICombiner.inc），从而避免了手工编写复杂的匹配逻辑，并保证了规则匹配过程的高效性与一致性。

\par

另一方面，C++回调机制则用于承担TableGen难以表达的复杂语义判断与指令重构工作。在合并过程中，许多优化决策依赖于位级信息推断（如KnownBits分析）、子目标特性（如DSP硬件功能单元支持情况）、以及对合法性与数据依赖关系的精细控制。这类逻辑通常需要借助C++代码访问分析结果并进行条件判断。因此，在每条合并规则中，具体的匹配判定与变换执行均由C++实现，用于根据匹配结果构造新的GMIR指令序列，并维护虚拟寄存器类型、数据流关系及指令依赖的一致性。

\par

仅采用基于TableGen的GICombiner难以准确表达复杂的语义依赖与分析驱动的优化条件，而完全依赖C++回调又会导致合并规则分散在大量手写代码中，降低规则的可读性与可维护性。基于上述考虑，本文采用TableGen负责结构化模式描述、C++回调负责语义判断与指令重写的混合设计方案，在保证合并优化表达能力的同时，有效提升了工程可维护性与扩展性。

\par

在实现层面，合并优化规则首先以GICombineRule的形式在td文件中声明，并由TableGen自动生成对应的匹配执行器代码。随后，这些规则由Combiner框架在MachineFunction粒度上统一调度与执行，对GMIR指令流进行遍历和合并，从而在指令合法化前后逐步消除冗余指令、重构指令序列，并提升最终生成代码的执行效率。

\par

在GlobalISel框架中，指令合法化阶段不仅是代码生成流程中的功能性边界，同时也是优化策略划分的重要分水岭。根据指令是否合法化，编译器能够执行的优化类型和优化空间存在显著差异，因此有必要分别在合法化前后引入针对性的优化策略。


%*********************************************************************
% 3.2 优化策略实现
%*********************************************************************
\section{优化策略实现}

基于前文对GlobalISel指令选择流程的分析可以发现，其冗余与低效并非集中于单一阶段，而是呈现出明显的阶段性特征：

\begin{itemize}
	\item
	在IRTranslator/Legalizer阶段，容易由于语义拆分与类型通用化引入冗余中间指令。
	
	\item
	在RegBankSelect阶段，可能产生跨寄存器组的数据拷贝。
	
	\item 
	在InstructionSelect阶段，则容易出现目标架构专用指令漏匹配的问题。
	
\end{itemize}

因此，单一位置的优化难以覆盖全部问题，本文将DSP后端的GlobalISel优化体系划分为合法化前（Pre-Legalize）与合法化后（Post-Legalize）两个层级，分别针对不同阶段的冗余特征实施有侧重的合并与重写策略。

\begin{enumerate}
	
	\item
	Pre-Legalize Combiner

合法化之前，GMIR仍处于高度通用的表示阶段，指令尚未被约束为DSP架构所支持的具体形式。该阶段的优化不涉及目标指令集的具体限制，重点在于语义层面的简化与结构性重写，以减少冗余并规范表达式形态，为后续Legalizer与Instruction Selector提供更加稳定的匹配条件，同时保留足够的优化自由度，主要包括以下几类：

\begin{itemize}
	\item
	表达式合并与规范化，如消除冗余的类型扩展（G\_ZEXT(G\_ZEXT(x))）、合并重复的算术或逻辑操作，为后续指令选择创造更简洁的模式。
	
	\item
	基于语义等价的指令融合，例如将G\_MUL+G\_ADD的通用表示提前重构为更利于匹配硬件乘加指令MAC的形式。
	
	\item 
	分析驱动的优化，如利用KnownBits、CSE等分析结果进行常量折叠、冗余计算消除和条件简化。
	
\end{itemize}

由于此阶段允许暂时存在非法指令，优化变换不必立即满足目标指令集的约束，从而具备更大的自由度，能够在保持语义不变的前提下，对指令结构进行深度重构。

	\item
	Post-Legalize Combiner

合法化之后，所有GMIR指令均已被转换为目标架构支持的合法形式，指令的类型、操作数位宽及内存访问方式均受到严格约束。此时优化的重点转向目标相关的性能优化与代码质量提升，主要包括以下几类：

\begin{itemize}
	\item
	目标指令匹配与替换优化，如将合法化后形成的指令序列进一步合并为DSP架构提供的伪指令或复合指令，以提升执行效率。
	
	\item
	指令调度友好的局部合并，通过消除多余拷贝、简化寄存器间的数据搬移，降低寄存器压力，为后续寄存器分配与指令调度创造更优条件。
	
	\item 
	面向代码密度和执行效率的微优化，如立即数折叠、访存地址计算合并以及针对硬件流水线特性的局部重写。
	
\end{itemize}

由于合法化后指令已经紧密贴合目标架构，这一阶段的优化虽在语义变换自由度上受限，但能够更直接地转化为实际的性能收益。

\end{enumerate}

基于上述两级优化体系的划分，本文在DSP后端中实现的具体优化策略可按照其生效阶段进行归类：其中面向通用GMIR结构、以消除语义拆分冗余和规范化表达式形态为目标的优化，统一放置于Pre-Legalize Combiner阶段；而依赖于合法化后稳定类型与操作数形态、以目标相关指令匹配和代码质量提升为目标的优化，则在Post-Legalize Combiner段实施。下文将结合具体优化实例，对上述两类优化策略的实现方式进行详细说明。


% 3.2.1 内存操作优化
\subsection{内存操作优化}
作为Pre-Legalize Combiner阶段的典型优化之一，内存操作指令的优化主要针对通用GMIR中高层内存操作所引入的函数调用冗余问题。在GlobalISel默认实现中，如G\_MEMCPY、G\_MEMMOVE等高层内存操作指令通常会被直接降级为库函数调用。然而，对于小规模内存操作而言，函数调用所引入的额外开销往往远大于实际的内存访问成本，从而导致显著的性能浪费。为此，本文在合法化之前引入针对高层内存操作的合并优化策略：主动将小规模内存拷贝操作转换为显式的load/store指令序列，以避免不必要的函数调用。

在DSP后端的Pre-Legalize Combiner中，针对内存操作指令的处理逻辑如下：

\begin{algorithm}[H]
	\caption{lowerMemCpyFamily}
	\KwIn{MachineInstr $MI$, unsigned $MaxLen$}
	\KwOut{LegalizeResult}
	
	$Opc \leftarrow$ opcode of $MI$\;
	\If{$Opc \notin \{G\_MEMCPY, G\_MEMMOVE, G\_MEMSET\}$}{
		\Return UnableToLegalize\;
	}
	
	extract $Dst$, $Src$, $Len$ and memory operands from $MI$\;
	obtain $DstAlign$, $SrcAlign$ (if applicable)\;
	
	\If{$Len$ is not constant}{
		\Return UnableToLegalize\;
	}
	\If{$Len = 0$}{
		erase $MI$; \Return Legalized\;
	}
	
	$IsVolatile \leftarrow$ volatility flag\;
	\If{$Opc = G\_MEMCPY\_INLINE$}{
		\Return lowerMemcpyInline(...)\;
	}
	\If{$IsVolatile$ \textbf{or} ($MaxLen>0$ \textbf{and} $Len>MaxLen$)}{
		\Return UnableToLegalize\;
	}
	
	\If{$Opc = G\_MEMCPY$}{
		compute store limit from target lowering\;
		\Return lowerMemcpy(...)\;
	}
	\If{$Opc = G\_MEMMOVE$}{
		\Return lowerMemmove(...)\;
	}
	\If{$Opc = G\_MEMSET$}{
		\Return lowerMemset(...)\;
	}
	
	\Return UnableToLegalize\;
\end{algorithm}


% 3.2.2 乘法优化
\subsection{乘法优化}
乘法指令优化属于Post-Legalize Combiner阶段的目标相关优化，其实现依赖于合法化后操作数位宽和指令形式的稳定性。对于乘数为编译期常量的整数乘法，直接生成乘法指令在部分架构上往往不是最优选择：一方面，整数乘法的硬件实现通常具有较高的延迟和功耗；另一方面，许多常量乘法在算术上可以等价地分解为移位与加减操作，从而以更低的执行成本完成相同计算。基于这一考虑，本文在合法化后阶段对G\_MUL指令引入常量乘法强度削减优化。当乘数为满足特定形式的编译期常量时，编译器将乘法操作替换为由移位（G\_SHL）与加法（G\_ADD）或减法（G\_SUB）组成的等价指令序列。

1.理论基础

从算术等价关系来看，若常量 $C$ 满足以下形式之一：
\begin{equation}
	C = 2^n \pm 1
\end{equation}
或
\begin{equation}
	C = (2^n \pm 1) \times 2^m
\end{equation}

则乘法运算可以通过移位与加减运算等价实现：
\begin{equation}
	x \times (2^n + 1) = (x \ll n) + x
\end{equation}

\begin{equation}
	x \times (2^n - 1) = (x \ll n) - x
\end{equation}

\begin{equation}
	x \times \big((2^n \pm 1) \times 2^m\big)
	= \big((x \ll n) \pm x\big) \ll m
\end{equation}

这些变换在保持程序语义完全一致的前提下，能够显著降低指令执行代价，并减少对乘法硬件单元的依赖。

2.匹配阶段

在匹配阶段，优化逻辑以G\_MUL指令为目标，对其操作数及常量特征进行系统分析，整体匹配流程如算法\ref{alg:const_mul_strength_reduction}所示。具体而言，该阶段主要包括以下三个步骤：

\begin{enumerate}
	\item
	常量识别：通过常量传播与等价查询机制，判断右操作数是否为编译期常量，获取乘法右操作数的常量值。
	
	\item
	位型分析：利用位运算分析常量的二进制结构，判断其是否满足上述形式。
	
	\item 
	约束检查：为避免干扰后续指令融合或破坏已存在的扩展语义，匹配阶段还会检查源操作数是否仅被当前指令使用以及排除可能影响符号扩展、零扩展或寄存器重用的场景。
	
\end{enumerate}

\begin{algorithm}[htbp]
	\SetAlgoLined
	\linespread{1}\selectfont
	
	\KwIn{MachineInstr $MI$}
	\KwOut{InstructionMapping or fail}
	\caption{Constant-Multiply Strength Reduction}
	\label{alg:const_mul_strength_reduction}
	
	\If{$opcode(MI) \neq G\_MUL$}{
		\Return fail\;
	}
	\If{RHS is not an integer constant}{
		\Return fail\;
	}
	
	$C \leftarrow sext(const(RHS))$\;
	$TZ \leftarrow countr\_zero(C)$\;
	$C' \leftarrow ashr(C, TZ)$\;
	
	\eIf{$C' > 0$}{
		\eIf{$(C' - 1)$ is power of two}{
			Rewrite as $(x \ll \log_2(C'-1)) + x$\;
		}{
			\If{$(C' + 1)$ is power of two}{
				Rewrite as $(x \ll \log_2(C'+1)) - x$\;
			}
			\Else{\Return fail\;}
		}
	}{
		\eIf{$(-C' + 1)$ is power of two}{
			Rewrite as $x - (x \ll \log_2(-C'+1))$\;
		}{
			\If{$(-C' - 1)$ is power of two}{
				Rewrite as $-( (x \ll \log_2(-C'-1)) + x )$\;
			}
			\Else{\Return fail\;}
		}
	}
	
	\Return success\;
\end{algorithm}

3.重写阶段

在重写阶段，编译器根据匹配到的常量形式，生成对应的移位与加减指令序列，并替换原有的G\_MUL指令。


% 3.2.3 拓展截断优化
\subsection{拓展截断优化}
除上述典型优化外，DSP后端中还实现了一些针对特定冗余模式和代码生成细节的补充优化。其中，部分优化在Pre-Legalize阶段生效，用于简化通用指令结构；另一部分则依赖于目标指令特性，在Post-Legalize阶段完成。

1.冗余截断与比较指令优化

在通用指令生成与合法化前的阶段，编译器常会引入形如截断+比较的冗余指令序列。这类模式通常表现为：先对一个宽位宽寄存器执行截断操作（G\_TRUNC），再将截断结果与零进行比较（G\_ICMP）。该现象多源于高层IR中的类型收缩、布尔表达式转换以及通用化指令拆分策略。

从语义角度分析，若被截断寄存器的高位仅由符号扩展产生，则这些高位在逻辑上并不携带有效信息。在这种情况下，对截断结果进行零比较，与直接对原始宽位宽值进行零比较在语义上是等价的。基于这一观察，本文在合法化前引入了针对冗余截断+比较模式的合并优化。

该优化首先利用KnownBits分析对被截断操作数进行位级信息推断，判断其高位是否完全由符号位扩展而来；若满足该条件，则说明截断操作并不会改变数值的符号与零值判定结果。此时，优化过程将原本以截断结果为操作数的比较指令，直接重写为对宽位宽操作数与零进行比较，同时移除多余的G\_TRUNC指令。一个典型的示例如表\ref{tab:trunc-icmp-opt}所示。

\noindent
\setlength{\tabcolsep}{0pt}
\renewcommand{\arraystretch}{1.0}

\begin{table}[htbp]
	\centering
	\caption{冗余截断与比较指令优化前后示例}
	\label{tab:trunc-icmp-opt}
	\renewcommand{\arraystretch}{1.0}
	\lstset{
		basicstyle=\ttfamily\footnotesize,
		frame=none,
		numbers=none
	}
	\begin{tabular}{|p{0.48\linewidth}|p{0.48\linewidth}|}
		\hline
		\begin{minipage}[t]{\linewidth}
			
			\begin{lstlisting}
				// 优化前
				%0:_(s64) = COPY $d0
				%1:_(s32) = G_CONSTANT i32 0
				%2:_(s32) = G_TRUNC %0:_
				%3:_(s1)  = G_ICMP slt, %1:_, %2:_
			\end{lstlisting}
		\end{minipage}
		&
		\begin{minipage}[t]{\linewidth}
			\begin{lstlisting}
				// 优化后	
				%0:_(s64) = COPY $d0
				%1:_(s32) = G_CONSTANT i32 0
				%3:_(s1)  = G_ICMP slt, %0:_, %1:_
			\end{lstlisting}
		\end{minipage}
		\\
		\hline
	\end{tabular}
\end{table}

通过这一变换，不仅可以减少一条通用中间指令和对应的虚拟寄存器定义，还能显著简化数据流依赖关系，使比较操作更贴近硬件语义。在DSP架构下，该优化有助于后续指令选择阶段更直接地匹配硬件比较指令与条件跳转指令，从而提升代码密度并降低执行延迟。

2.拓展下推优化

在GMIR中，算术指令往往作用于经过符号扩展G\_SEXT或零扩展G\_ZEXT后的操作数。这种形式虽然在语义上是正确的，但在实际工程中会引入多余的扩展指令，导致指令数量的增加及后续目标指令匹配与融合的成功率的降低。为此，本文引入一种EPO（Extension Pushing Optimization，扩展下推优化），优化通过重写算术运算与扩展指令的组合形式，将算术操作下推至扩展之前，从而获得更加规范、紧凑的中间表示。

\par

考虑如下典型模式：

\[
\operatorname{add}(\operatorname{zext}\, x,\ \operatorname{zext}\, y)
\]

该形式在GMIR中表现为两个扩展指令后接一条算术指令。由于DSP指令集中包含带扩展的算术指令，允许在较小位宽上直接完成算术运算，再对结果进行一次统一扩展。因此，将算术操作推到扩展之前能够减少冗余的扩展指令数量，降低指令条数。除此之外，还能形成更规范的IR结构，提升指令选择阶段的模式匹配成功率。

\par

该优化针对ADD和SUB指令，适用于零扩展与符号扩展两种情形，其核心重写规则可概括为：

\[
\operatorname{op}\bigl(\operatorname{ext}\, x,\ \operatorname{ext}\, y\bigr)
\;\Rightarrow\;
\operatorname{ext}\!\bigl(\operatorname{op}(x, y)\bigr)
\]

其中，op表示算术操作ADD或SUB，ext表示扩展操作ZEXT或SEXT。需要注意的是，变换过程中必须保证扩展类型的一致性，并在符号扩展场景下正确维护符号语义。在Combiner中，该优化通过参数化的TableGen规则进行描述。其核心定义如下：

\begin{lstlisting}[language=C++, caption={EPO的TableGen规则}, label={lst:epo_tb}]
	class epo_base<Instruction opcode, Instruction extOpcode>
	: GICombineRule <
	(defs root:$root),
	(match (extOpcode $ext1, $src1):$ExtMI,
	(extOpcode $ext2, $src2),
	(opcode $dst, $ext1, $ext2):$root,
	[{ return matchEPO(*${root}, MRI, $dst, $src1, $src2); }]),
	(apply [{
		applyEPO(*${root}, MRI, B,
		${ExtMI}->getOpcode() == TargetOpcode::G_SEXT, $dst, $src1, $src2);
	}])
	>;
\end{lstlisting}

该规则通过模板参数抽象了算术操作类型ADD/SUB以及扩展类型ZEXT/SEXT，从而避免重复定义多条相似规则。在匹配阶段，规则要求两个操作数均来源于相同类型的扩展指令，并由指定的算术指令使用；在应用阶段，根据扩展类型生成新的算术指令，并在必要时重新插入对应的扩展操作。该优化在语义上是安全的，其正确性基于如下事实：

\begin{itemize}
	\item 对于零扩展ZEXT，扩展前后的值在无符号算术意义下保持一致.
	
	\item 对于符号扩展SEXT，在保证算术运算不发生未定义行为的前提下，先运算后扩展与先扩展后运算在数学语义上等价.
	
	\item 优化过程中不改变数据依赖关系，仅调整指令组合方式。
	
\end{itemize}

EPO属于一种IR规范化优化，其主要作用并非直接降低执行时间，而是为后续目标相关优化与指令选择提供更优的输入形式。在DSP架构上，该优化提升了复合指令匹配的成功率，并间接减少了最终生成代码中的指令数量。


% 3.2.4 立即数装载优化
\subsection{立即数装载优化}
在指令选择阶段，G\_CONSTANT/G\_FCONSTANT等通用指令需要被转化为目标指令集可执行的装载立即数序列。如果不加区分地统一使用通用长立即数装载指令MOVI，会导致指令条数增加。因此，本文根据DSP平台的ISA来定制化立即数序列的装载函数，采用按常量位型分类的策略：优先长度匹配更短、开销更少的装载形式，从而降低代码尺寸与执行开销。可以将32位立即数分为几种情况:

\begin{itemize}
	\item
	高16位全0的常量：当立即数的高16位全0时，有两种方案：
	\begin{itemize}
		\item
		利用MOVIGLZ指令实现，实现将低16位写入寄存器，并将高16位置零。
		
		\item
		利用立即数加法指令ADDI实现，不直接为寄存器赋值，而是借助零寄存器来实现。

	\end{itemize}
	
	\item
	可用16位有符号立即数表示的常量：利用MOVIGLX指令可以实现将一个16位的有符号立即数进行符号位扩展至32bit后复制到rd中。于是当常量满足Imm∈\([-2^{15},\, 2^{15}-1]\)
	 时，可将imm16符号扩展到32位写入Rd。
	
	\item 
	其他情况：使用PseudoMOVI伪指令实现，伪指令会在后续阶段展开为MOVIGH+MOVIGL两条机器指令。其中MOVIGH装载立即数的高16位到寄存器高半区，而MOVIGL装载立即数的低16位到寄存器低半区。
	
\end{itemize}



%*********************************************************************
% 3.3 本章小结
%*********************************************************************
\section{本章小结}


