\chapter{面向DSP的全局指令选择优化策略}


%*********************************************************************
% 3.1 优化策略分析与设计
%*********************************************************************
\section{优化策略分析与设计}
经过GMIR生成、指令合法化、寄存器组选择以及机器指令选择4个Pass之后，原来的LLVM IR转换成了MIR。尽管这一流程已经实现了指令选择的目标，但是转换之后生成的代码质量相比于SelectionDAGISel较差。这个差距主要体现在指令数量增加，专用指令利用率低，寄存器选取不够精细高效等。

\par

为了提升GlobalISel生成代码的质量并缩小其与SelectionDAGISel之间的差距，本文引入了包括CSE（Common Subexpression Elimination, 公共子表达式消除）、KnownBits Analysis（已知位分析）以及Combiner（合并优化）等优化策略。这些优化策略通过减少重复子表达式、利用比特级已知信息指导指令选择，并在保持语义等价的前提下合并和简化指令序列，从而降低了指令冗余度，提升了生成代码的性能表现。


% 3.1.1 优化策略理论依据
\subsection{优化策略理论依据}
程序编译过程（尤其是从高层LLVM IR编译到目标特定低级指令时）必然引入大量的冗余，这些冗余由计算冗余（公共子表达式重复计算）、数据冗余（冗余拷贝）和表示冗余（大量更复杂的指令序列可以用更简单的指令序列来表示）等引起。优化的任务就是要系统地检测、消除这些冗余，在程序语义不变的前提下提高程序生成代码执行效率、代码密度、硬件利用率等。

\par
GlobalISel与SelectionDAGISel在代码质量上的差异，根本原因在于二者的设计目标与实现方式不同。SelectionDAGISel是针对特定架构定制的设计，其核心中间表示SelectionDAG天然具备对基本块内局部计算图进行重写、合并与规约的能力，从而能够在指令选择阶段有效消除冗余计算；GlobalISel为了支持不同架构指令集的特性而采用通用中间表示+模块Pass的设计，因此在中间代码产生时会不可避免地产生冗余，产生这种冗余的原因主要有三点：

\begin{enumerate}
	\item
	通用化转换带来的语义冗余：为保证跨架构语义的一致性，GlobalISel在LLVM IR向GMIR转换及指令合法化阶段，会将复杂运算拆分为一系列简单的原子指令。例如，将DSP架构的乘加运算（MAC）拆分为乘法与加法指令，将宽类型数据访问拆分为多次窄类型加载/存储指令，这种拆分虽保证了语义正确性，却引入了大量指令级冗余。
	
	\item
	寄存器组选择的局部性局限：在寄存器组选择阶段，寄存器组的分配以基本块为粒度，没有充分考虑函数级的全局数据流依赖，容易产生频繁地跨基本块数据复制。例如循环变量在不同基本块中被分配到不同寄存器组，需通过专用复制指令完成数据迁移，这显著增加了执行延迟。
	
	\item 
	硬件特性适配的滞后性：机器指令选择阶段的主要目的是完成从通用GMIR到目标指令的语义映射，因而默认采取的是局部的、简单的一对一语义映射。复杂指令模式的识别被推迟到了较晚的阶段，编译器无法及时识别跨越多条GMIR指令的复杂语义，也就无法完整、充分地挖掘硬件中专用功能单元性能潜力。
	
\end{enumerate}

从理论上讲，高效优化的前提是要基于精确可靠的程序分析。数据流分析（如CSE所依赖的可用表达式分析）揭示了值是如何在程序中产生和传播的；而信息流分析（如KnownBits分析）则是在位级层面推断值的范围。这些分析保证了上述优化变换的可行性及可靠性。

\par

从实际上讲，DSP处理器指令集中有一些专门针对特定模式的指令设计，如乘加、向量加载/存储及多数据并行运算指令。优化需要具备识别指令模式的能力，能在合适的阶段将通用操作序列转化成高度优化的硬件操作命令。只有在分析与变换机制的支撑下才能使编译器既能保证通用性，又能生成高性能、高效率的目标代码。


% 3.1.2 关键优化技术分析
\subsection{关键优化技术分析}


\subsubsection{1.公共子表达式消除}
公共子表达式消除是一种经典的编译优化技术，其核心思想是消除程序中重复计算相同表达式的冗余操作，避免冗余的运算操作与寄存器占用，从而精简代码体积、降低执行延迟。在指令选择阶段，如果一个表达式的值已经被计算过，并且其操作数未被重新定义，则可以复用之前的计算结果，避免重复计算，从而减少冗余指令的生成。如下代码块\ref{lst:cse_before}和代码块\ref{lst:cse_after}所示，该样例在优化前b+c被计算了3次，优化后只需要计算1次。

\begin{figure}[htbp]
	\centering
	\begin{minipage}[t]{0.48\linewidth}
		\captionsetup{type=lstlisting}
		\begin{lstlisting}[language=C++, caption={CSE优化前}, label={lst:cse_before}]
	a = b + c;
	d = b + c;
	e = b + c * 2;
	f = (b + c) * 3;

		\end{lstlisting}
	\end{minipage}\hfill
	\begin{minipage}[t]{0.48\linewidth}
		\captionsetup{type=lstlisting}
		\begin{lstlisting}[language=C++, caption={CSE优化后}, label={lst:cse_after}]
	temp = b + c;
	a = temp;
	d = temp;
	e = b + c * 2;
	f = temp * 3;
		\end{lstlisting}
	\end{minipage}
\end{figure}

与传统的CSE不同，GlobalISel使用了Continuous CSE（持续CSE）策略。Continuous CSE会在指令创建阶段检查是否已经存在语义等价的表达式，一旦发现可复用的结果便直接进行替换，从而消除不必要的冗余计算指令。与基于全函数或全基本块扫描的传统CSE不同，Continuous CSE主要作用于基本块内部，以增量式方式维护可消除的表达式集合，在不引入额外全局分析开销的前提下实现有效的冗余消除。这种局部的优化策略能够降低指令冗余，在保持优化效果的同时提升编译效率。

\par

CSE不仅能够消除冗余指令，为后续优化创造更多的机会，而且还能减少寄存器的使用。在指令合并优化阶段，复用公共子表达式的计算结果往往能够暴露出更复杂的合并模式。例如，如果两个计算共享相同的子表达式，合并优化可能通过识别这些冗余的计算来进一步简化指令序列，提升代码执行效率。


\subsubsection{2.已知位分析}
已知位分析是一种静态推断寄存器各位已知状态的技术，通过向其他Pass提供已知位信息，从而支持后续的各类优化变换。该分析通过跟踪每个位的已知状态来帮助优化器做决策，其核心目标是在不引入额外运行时开销的前提下，尽可能提前获取寄存器值的精确信息，从而辅助常量传播、指令简化以及后续的合并优化决策。该分析通过对寄存器中必然为0或必然为1的比特位进行建模，为优化器提供细粒度的位级语义信息。除此之外，该分析采用懒计算的方式，仅在实际使用相关信息时才进行计算，因此能够有效避免不必要的分析开销。

\par

已知位分析以寄存器的初始比特状态作为分析起点。这些初始信息可能来源于多种途径，例如：函数参数在ABI层面的位宽约束、全局变量的初始化值、字面量常量的比特分布，或前序优化阶段已推导出的比特属性。随后，分析沿着指令的数据流依赖关系，对寄存器的比特信息进行逐指令传播与更新。

\par

从实现层面来看，已知位分析需要为每个寄存器维护两个位掩码：KnownZeros和KnownOnes。其中KnownZeros用于标记所有必然为0的位，KnownOnes用于标记所有必然为1的位，其余未被标记的位则视为未知。在指令流的传播过程中，这两个掩码会随着指令语义不断更新，使寄存器的比特级已知信息逐步得到强化和完善。下面的示例展示了已知位分析在简单算术与逻辑运算中的效果：

\lstset{language=c++}
\begin{lstlisting}
	int test(int a) {
		int b = a & 0xFFFF;   // 低16位保留，高16位必为0
		int c = b | 0x10000;  // 第17位必为1
		return c;
	}
	// b: KnownZeros = 0xFFFF0000, KnownOnes = 0x00000000
	// c: KnownZeros = 0xFFFE0000, KnownOnes = 0x00010000
\end{lstlisting}

在经过了上述分析后，编译器能够判断出变量b的高16位必然为0，而变量c的第17位必然为1。这类信息在后续优化阶段具有重要价值，一方面可用于消除冗余的掩码、扩展或比较指令；另一方面也为指令合并与目标指令匹配提供更精确的语义依据，从而生成更紧凑、高效的机器代码。


\subsubsection{3.合并优化}
合并优化是一种将特定指令模式转换位更优形式的优化。在GlobalISel框架中，合并优化是改进代码质量的一个重要手段。合并优化的目的是消除冗余的指令并简化表达式，合并常见的操作模式来减少代码的规模，提高执行效率。合并优化可以充分利用目标架构的复杂指令，减少多余的计算以及对存储器的访问等。

\par

合并优化实际上也可以看作是Peephole Optimization（窥孔优化）的一种推广，不过其优化的范围已经不再局限于固定长度的局部指令片段窗口，而是在更长的指令片段范围上进行模式匹配与优化重写，支持跨多条指令、跨基本块的优化。该优化策略的理论基础主要来源于以下几个方面的观察：

\begin{itemize}
	\item
	在低级代码生成过程中，为了便于表达中间计算结果，编译器会产生一系列指令结构简单但语义相关的指令序列，这会导致生成的指令存在冗余。目标架构如果有语义等价但更为复杂的单条指令形式，这些冗余的指令序列通常可以被这条高效指令所替代，从而减少了指令数量以及中间结果的产生。
	
	\item
	指令之间的数据流局部性比较强。相邻的指令会共享操作数或者存在直接的定义和使用关系，这为编译器识别可合并的操作模式提供了天然条件，可以使合并优化在保持程序语义不变的情况下对一系列指令进行整体的重构。
	
	\item 
	随着现代处理器指令集日益丰富，乘累加、融合算术以及向量化等复杂指令日益普及。合并优化在通用中间表示与这些复杂目标指令之间发挥着关键衔接作用，也是影响编译器利用目标机器计算能力的紧要因素。
	
\end{itemize}

在GlobalISel中，合并优化贯穿整个指令选择阶段，在各个关键节点对中间表示进行等价重写和规约，逐步引导中间表示向更加符合目标架构特性的形式演化，从而在保持整体编译流程模块化的同时，有效提升最终生成代码的质量。具体流程如图\ref{fig:combiner}所示。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/combiner.png}
	\caption{GlobalISel合并优化流程示意图}
	\label{fig:combiner}
\end{figure}


% 3.1.3 面向DSP的优化设计
\subsection{面向DSP的优化设计}
单一的优化策略通常难以应对复杂的代码生成需求，因此需要一个多策略协同的优化体系。本章将深入分析以合并优化为核心，并辅以公共子表达式消除、合法化策略以及窥孔优化等多种策略的全局指令选择优化方法。由于公共子表达式消除属于通用优化且已经在框架中实现，只需要调用相应的接口即可，下文主要针对合并优化。

\par

为在GlobalISel框架下实现高效、可扩展的DSP优化，本文采用基于TableGen的 GICombiner描述机制与C++回调逻辑相结合的实现路径。该设计充分利用了两种机制在表达能力与工程组织上的互补优势，实现了合并优化规则的高效描述与可靠执行。

\par

具体而言，基于TableGen的GICombiner主要用于描述可合并指令的结构化模式。通过在td文件中定义GICombineRule，可以以声明式的方式刻画指令之间的拓扑关系、操作码组合以及操作数约束条件。TableGen在编译阶段自动生成对应的匹配执行器代码（ 如合法化前的DSPGenPreLegalizeGICombiner.inc），从而避免了手工编写复杂的匹配逻辑，并保证了规则匹配过程的高效性与一致性。

\par

另一方面，C++回调机制则用于承担TableGen难以表达的复杂语义判断与指令重构工作。在合并过程中，许多优化决策依赖于位级信息推断（如KnownBits分析）、子目标特性（如DSP硬件功能单元支持情况）、以及对合法性与数据依赖关系的精细控制。这类逻辑通常需要借助C++代码访问分析结果并进行条件判断。因此，在每条合并规则中，具体的匹配判定与变换执行均由C++实现，用于根据匹配结果构造新的GMIR指令序列，并维护虚拟寄存器类型、数据流关系及指令依赖的一致性。

\par

仅采用基于TableGen的GICombiner难以准确表达复杂的语义依赖与分析驱动的优化条件，而完全依赖C++回调又会导致合并规则分散在大量手写代码中，降低规则的可读性与可维护性。基于上述考虑，本文采用TableGen负责结构化模式描述、C++回调负责语义判断与指令重写的混合设计方案，在保证合并优化表达能力的同时，有效提升了工程可维护性与扩展性。

\par

在实现层面，合并优化规则首先以GICombineRule的形式在td文件中声明，并由TableGen自动生成对应的匹配执行器代码。随后，这些规则由Combiner框架在MachineFunction粒度上统一调度与执行，对GMIR指令流进行遍历和合并，从而在指令合法化前后逐步消除冗余指令、重构指令序列，并提升最终生成代码的执行效率。

\par

在GlobalISel框架中，指令合法化阶段不仅构成代码生成流程中的关键功能边界，同时也是优化策略划分的重要依据。由于指令在合法化前后，其类型信息、操作数形态及目标相关约束的完备程度存在显著差异，编译器在不同阶段所能实施的优化类型与优化空间也随之发生变化。基于这一特点，本文在DSP后端中将优化策略按生效阶段进行系统化划分：一类面向通用GMIR表达，主要针对语义拆分冗余消除与表达式规范化，统一在Pre-Legalize Combiner阶段实施；另一类则依赖合法化后稳定的类型与操作数信息，侧重于目标相关指令匹配与代码质量提升，在Post-Legalize Combiner阶段完成。下文将结合具体优化实例，对上述两类优化策略的设计与实现进行详细分析。


%*********************************************************************
% 3.2 合法化前优化策略
%*********************************************************************
\section{合法化前优化策略}
合法化之前，GMIR仍处于高度通用的表示阶段，指令尚未被约束为DSP架构所支持的具体形式。该阶段的优化不涉及目标指令集的具体限制，重点在于语义层面的简化与结构性重写，以减少冗余并规范表达式形态，为后续Legalizer与Instruction Selector提供更加稳定的匹配条件，同时保留足够的优化自由度，主要包括以下几类：

\begin{itemize}
	\item
	表达式合并与规范化，如消除冗余的类型扩展（G\_ZEXT(G\_ZEXT(x))）、合并重复的算术或逻辑操作，为后续指令选择创造更简洁的模式。
	
	\item
	基于语义等价的指令融合，例如将G\_MUL+G\_ADD的通用表示提前重构为更利于匹配硬件乘加指令MAC的形式。
	
	\item 
	分析驱动的优化，如利用KnownBits、CSE等分析结果进行常量折叠、冗余计算消除和条件简化。
	
\end{itemize}

由于此阶段允许暂时存在非法指令，优化变换不必立即满足目标指令集的约束，从而具备更大的自由度，能够在保持语义不变的前提下，对指令结构进行深度重构。


% 3.2.1 内存操作优化
\subsection{内存操作优化}
作为Pre-Legalize Combiner阶段的典型优化之一，内存操作指令的优化主要针对通用GMIR中高层内存操作所引入的函数调用冗余问题。在GlobalISel默认实现中，如G\_MEMCPY、G\_MEMMOVE等高层内存操作指令通常会被直接降级为库函数调用。然而，对于小规模内存操作而言，函数调用所引入的额外开销往往远大于实际的内存访问成本，从而导致显著的性能浪费。为此，本文在合法化之前引入针对高层内存操作的合并优化策略：主动将小规模内存拷贝操作转换为显式的load/store指令序列，以避免不必要的函数调用。

\par

在DSP后端的Pre-Legalize Combiner中，针对内存操作指令的处理逻辑如下：

\begin{algorithm}[H]
	\caption{lowerMemCpyFamily}
	\KwIn{MachineInstr $MI$, unsigned $MaxLen$}
	\KwOut{LegalizeResult}
	
	$Opc \leftarrow$ opcode of $MI$\;
	\If{$Opc \notin \{G\_MEMCPY, G\_MEMMOVE, G\_MEMSET\}$}{
		\Return UnableToLegalize\;
	}
	
	extract $Dst$, $Src$, $Len$ and memory operands from $MI$\;
	obtain $DstAlign$, $SrcAlign$ (if applicable)\;
	
	\If{$Len$ is not constant}{
		\Return UnableToLegalize\;
	}
	\If{$Len = 0$}{
		erase $MI$; \Return Legalized\;
	}
	
	$IsVolatile \leftarrow$ volatility flag\;
	\If{$Opc = G\_MEMCPY\_INLINE$}{
		\Return lowerMemcpyInline(...)\;
	}
	\If{$IsVolatile$ \textbf{or} ($MaxLen>0$ \textbf{and} $Len>MaxLen$)}{
		\Return UnableToLegalize\;
	}
	
	\If{$Opc = G\_MEMCPY$}{
		compute store limit from target lowering\;
		\Return lowerMemcpy(...)\;
	}
	\If{$Opc = G\_MEMMOVE$}{
		\Return lowerMemmove(...)\;
	}
	\If{$Opc = G\_MEMSET$}{
		\Return lowerMemset(...)\;
	}
	
	\Return UnableToLegalize\;
\end{algorithm}


% 3.2.2 拓展截断优化
\subsection{拓展截断优化}
除上述典型优化外，DSP后端中还实现了一些针对特定冗余模式和代码生成细节的补充优化。其中，部分优化在Pre-Legalize阶段生效，用于简化通用指令结构；另一部分则依赖于目标指令特性，在Post-Legalize阶段完成。


\subsubsection{1.冗余截断与比较指令优化}
在通用指令生成与合法化前的阶段，编译器常会引入形如截断+比较的冗余指令序列。这类模式通常表现为：先对一个宽位宽寄存器执行截断操作（G\_TRUNC），再将截断结果与零进行比较（G\_ICMP）。该现象多源于高层IR中的类型收缩、布尔表达式转换以及通用化指令拆分策略。

从语义角度分析，若被截断寄存器的高位仅由符号扩展产生，则这些高位在逻辑上并不携带有效信息。在这种情况下，对截断结果进行零比较，与直接对原始宽位宽值进行零比较在语义上是等价的。基于这一观察，本文在合法化前引入了针对冗余截断+比较模式的合并优化。

该优化首先利用KnownBits分析对被截断操作数进行位级信息推断，判断其高位是否完全由符号位扩展而来；若满足该条件，则说明截断操作并不会改变数值的符号与零值判定结果。此时，优化过程将原本以截断结果为操作数的比较指令，直接重写为对宽位宽操作数与零进行比较，同时移除多余的G\_TRUNC指令。一个典型的示例如代码块\ref{lst:trunc_before}和代码块\ref{lst:trunc_after}所示。

\begin{figure}[htbp]
	\centering
	\begin{minipage}[t]{0.48\linewidth}
		\captionsetup{type=lstlisting}
		\begin{lstlisting}[language=C++, caption={CSE优化前}, label={lst:trunc_before}]
	%0:_(s64) = COPY $d0
	%1:_(s32) = G_CONSTANT i32 0
	%2:_(s32) = G_TRUNC %0:_
	%3:_(s1)  = G_ICMP slt, %1:_, %2:_
		\end{lstlisting}
	\end{minipage}\hfill
	\begin{minipage}[t]{0.48\linewidth}
		\captionsetup{type=lstlisting}
		\begin{lstlisting}[language=C++, caption={CSE优化后}, label={lst:trunc_after}]
	%0:_(s64) = COPY $d0
	%1:_(s32) = G_CONSTANT i32 0
	%3:_(s1)  = G_ICMP slt, %0:_, %1:_
	
		\end{lstlisting}
	\end{minipage}
\end{figure}

通过这一变换，不仅可以减少一条通用中间指令和对应的虚拟寄存器定义，还能显著简化数据流依赖关系，使比较操作更贴近硬件语义。在DSP架构下，该优化有助于后续指令选择阶段更直接地匹配硬件比较指令与条件跳转指令，从而提升代码密度并降低执行延迟。


\subsubsection{2.拓展下推优化}
在GMIR中，算术指令往往作用于经过符号扩展G\_SEXT或零扩展G\_ZEXT后的操作数。这种形式虽然在语义上是正确的，但在实际工程中会引入多余的扩展指令，导致指令数量的增加及后续目标指令匹配与融合的成功率的降低。为此，本文引入一种EPO（Extension Pushing Optimization，扩展下推优化），优化通过重写算术运算与扩展指令的组合形式，将算术操作下推至扩展之前，从而获得更加规范、紧凑的中间表示。

\par

考虑如下典型模式：

\[
\operatorname{add}(\operatorname{zext}\, x,\ \operatorname{zext}\, y)
\]

该形式在GMIR中表现为两个扩展指令后接一条算术指令。由于DSP指令集中包含带扩展的算术指令，允许在较小位宽上直接完成算术运算，再对结果进行一次统一扩展。因此，将算术操作推到扩展之前能够减少冗余的扩展指令数量，降低指令条数。除此之外，还能形成更规范的IR结构，提升指令选择阶段的模式匹配成功率。

\par

该优化针对ADD和SUB指令，适用于零扩展与符号扩展两种情形，其核心重写规则可概括为：

\[
\operatorname{op}\bigl(\operatorname{ext}\, x,\ \operatorname{ext}\, y\bigr)
\;\Rightarrow\;
\operatorname{ext}\!\bigl(\operatorname{op}(x, y)\bigr)
\]

其中，op表示算术操作ADD或SUB，ext表示扩展操作ZEXT或SEXT。需要注意的是，变换过程中必须保证扩展类型的一致性，并在符号扩展场景下正确维护符号语义。在Combiner中，该优化通过参数化的TableGen规则进行描述。其核心定义如下：

\begin{lstlisting}[language=C++, caption={EPO的TableGen规则}, label={lst:epo_tb}]
	class epo_base<Instruction opcode, Instruction extOpcode>
	: GICombineRule <
	(defs root:$root),
	(match (extOpcode $ext1, $src1):$ExtMI,
	(extOpcode $ext2, $src2),
	(opcode $dst, $ext1, $ext2):$root,
	[{ return matchEPO(*${root}, MRI, $dst, $src1, $src2); }]),
	(apply [{
		applyEPO(*${root}, MRI, B,
		${ExtMI}->getOpcode() == TargetOpcode::G_SEXT, $dst, $src1, $src2);
	}])
	>;
\end{lstlisting}

该规则通过模板参数抽象了算术操作类型ADD/SUB以及扩展类型ZEXT/SEXT，从而避免重复定义多条相似规则。在匹配阶段，规则要求两个操作数均来源于相同类型的扩展指令，并由指定的算术指令使用；在应用阶段，根据扩展类型生成新的算术指令，并在必要时重新插入对应的扩展操作。该优化在语义上是安全的，其正确性基于如下事实：

\begin{itemize}
	\item 对于零扩展ZEXT，扩展前后的值在无符号算术意义下保持一致.
	
	\item 对于符号扩展SEXT，在保证算术运算不发生未定义行为的前提下，先运算后扩展与先扩展后运算在数学语义上等价.
	
	\item 优化过程中不改变数据依赖关系，仅调整指令组合方式。
	
\end{itemize}

EPO属于一种IR规范化优化，其主要作用并非直接降低执行时间，而是为后续目标相关优化与指令选择提供更优的输入形式。在DSP架构上，该优化提升了复合指令匹配的成功率，并间接减少了最终生成代码中的指令数量。


%*********************************************************************
% 3.3 合法化后优化策略
%*********************************************************************
\section{合法化后优化策略}
合法化之后，所有GMIR指令均已被转换为目标架构支持的合法形式，指令的类型、操作数位宽及内存访问方式均受到严格约束。此时优化的重点转向目标相关的性能优化与代码质量提升，主要包括以下几类：

\begin{itemize}
	\item
	目标指令匹配与替换优化，如将合法化后形成的指令序列进一步合并为DSP架构提供的伪指令或复合指令，以提升执行效率。
	
	\item
	指令调度友好的局部合并，通过消除多余拷贝、简化寄存器间的数据搬移，降低寄存器压力，为后续寄存器分配与指令调度创造更优条件。
	
	\item 
	面向代码密度和执行效率的微优化，如立即数折叠、访存地址计算合并以及针对硬件流水线特性的局部重写。
	
\end{itemize}

由于合法化后指令已经紧密贴合目标架构，这一阶段的优化虽在语义变换自由度上受限，但能够更直接地转化为实际的性能收益。


% 3.3.1 立即数装载优化
\subsection{立即数装载优化}
在指令选择阶段，G\_CONSTANT和G\_FCONSTANT需要被转化为目标指令集可执行的装载立即数序列。对于DSP后端而言，指令采用固定32位编码格式。由于指令由操作码与操作数组成，且立即数字段的编码宽度通常不超过16位，单条指令中可用于表示立即数的位数受到严格限制，因此32位常量一般无法通过单条指令直接完成装载。因此，对于32位立即数，若不加区分地统一采用长立即数装载伪指令MOVI，则会引入额外的指令开销。

\par

针对上述问题，本文结合DSP平台的ISA特性，在全局指令选择阶段对立即数装载过程进行定制化优化。核心思想是根据常量的位型特征对立即数进行分类，并优先选择编码长度更短、执行开销更低的装载形式，从而在保证语义正确性的前提下减少冗余指令。以32位立即数为例，可将其划分为以下三类情况。


\subsubsection{1.立即数的高16位全0}
当立即数的高16位全0时，常量可视为一个零扩展的16位无符号数，只需要装载低16位即可。由于硬件指令集的限制，即使高16位全为0，也无法省略对高位赋值的操作。为此，本文引入基于零寄存器的装载策略，通过设置一个零寄存器并将零寄存器作为源操作数，结合立即数加法或专用低位装载指令来完成常量生成，从而避免使用通用的长立即数序列。

\begin{figure}[htbp]
	\centering
	\begin{minipage}[t]{0.48\linewidth}
		\captionsetup{type=lstlisting}
		\begin{lstlisting}[language=C++, caption={CSE优化前}, label={lst:imm_con1_before}]
	MOVIGH GR2 0x0;
	MOVIGL GR2 0x1;
		\end{lstlisting}
	\end{minipage}\hfill
	\begin{minipage}[t]{0.48\linewidth}
		\captionsetup{type=lstlisting}
		\begin{lstlisting}[language=C++, caption={CSE优化后}, label={lst:imm_con1_after}]
	ADDI ZERO 0x1;
			
		\end{lstlisting}
	\end{minipage}
\end{figure}


\subsubsection{2.立即数的高17位全1}
当立即数的高17位全为1，即为可用16位有符号立即数表示的常量时，可以利用MOVIGLX指令来实现将一个16位的有符号立即数进行符号位扩展至32bit后复制到rd中。于是当常量满足Imm∈\([-2^{15},\, 2^{15}-1]\)时，可将imm16符号扩展到32位写入Rd。

\begin{figure}[htbp]
	\centering
	\begin{minipage}[t]{0.48\linewidth}
		\captionsetup{type=lstlisting}
		\begin{lstlisting}[language=C++, caption={CSE优化前}, label={lst:imm_con2_before}]
	MOVIGH GR2 0xFFFF;
	MOVIGL GR2 0xF123;
		\end{lstlisting}
	\end{minipage}\hfill
	\begin{minipage}[t]{0.48\linewidth}
		\captionsetup{type=lstlisting}
		\begin{lstlisting}[language=C++, caption={CSE优化后}, label={lst:imm_con2_after}]
	MOVIGLX GR2 0xF123;

		\end{lstlisting}
	\end{minipage}
\end{figure}


\subsubsection{3.其他情况}
对于不满足上述情况的立即数，由于无法通过单条指令完成装载，只能使用伪指令拓展的长立即数装载方式，伪指令会在后续阶段展开为MOVIGH和MOVIGL两条机器指令。其中MOVIGH装载立即数的高16位到寄存器高半区，而MOVIGL装载立即数的低16位到寄存器低半区。

\par

上述优化策略在指令选择阶段完成判定与映射，避免了在后续低层次优化中再对立即数序列进行修正。通过对立即数位型的精细化分类，该方法在不增加指令选择复杂度的前提下，有效减少了冗余指令的生成，为后续寄存器分配与指令调度提供了更紧凑的输入形式。该优化能够在控制流密集与常量使用频繁的程序中显著降低代码尺寸，并对整体执行效率产生积极影响。


% 3.2.2 乘法优化
\subsection{乘法优化}
对于乘数为编译期常量的整数乘法，直接生成乘法指令不是最优选择。一方面，整数乘法的硬件实现通常具有较高的延迟和功耗；另一方面，许多常量乘法在算术上可以等价地分解为移位与加减操作，从而以更低的执行成本完成相同计算。基于这一考虑，本文在合法化后阶段对G\_MUL指令引入常量乘法强度削减优化。当乘数为满足特定形式的编译期常量时，编译器将乘法操作替换为由移位G\_SHL与加法G\_ADD或减法G\_SUB组成的等价指令序列。


\subsubsection{1.理论基础}
从算术等价关系来看，若常量 $C$ 满足以下形式之一：
\begin{equation}
	C = 2^n \pm 1
\end{equation}
或
\begin{equation}
	C = (2^n \pm 1) \times 2^m
\end{equation}

则乘法运算可以通过移位与加减运算等价实现：
\begin{equation}
	x \times (2^n + 1) = (x \ll n) + x
\end{equation}

\begin{equation}
	x \times (2^n - 1) = (x \ll n) - x
\end{equation}

\begin{equation}
	x \times \big((2^n \pm 1) \times 2^m\big)
	= \big((x \ll n) \pm x\big) \ll m
\end{equation}

这些变换在保持程序语义完全一致的前提下，能够显著降低指令执行代价，并减少对乘法硬件单元的依赖。


\subsubsection{2.匹配阶段}
在匹配阶段，优化逻辑以G\_MUL指令为目标，对其操作数及常量特征进行系统分析，整体匹配流程如算法\ref{alg:const_mul_strength_reduction}所示。具体而言，该阶段主要包括以下三个步骤：

\begin{enumerate}
	\item
	常量识别：通过常量传播与等价查询机制，判断右操作数是否为编译期常量，获取乘法右操作数的常量值。
	
	\item
	位型分析：利用位运算分析常量的二进制结构，判断其是否满足上述形式。
	
	\item 
	约束检查：为避免干扰后续指令融合或破坏已存在的扩展语义，匹配阶段还会检查源操作数是否仅被当前指令使用以及排除可能影响符号扩展、零扩展或寄存器重用的场景。
	
\end{enumerate}

\begin{algorithm}[htbp]
	\SetAlgoLined
	\linespread{1}\selectfont
	
	\KwIn{MachineInstr $MI$}
	\KwOut{InstructionMapping or fail}
	\caption{Constant-Multiply Strength Reduction}
	\label{alg:const_mul_strength_reduction}
	
	\If{$opcode(MI) \neq G\_MUL$}{
		\Return fail\;
	}
	\If{RHS is not an integer constant}{
		\Return fail\;
	}
	
	$C \leftarrow sext(const(RHS))$\;
	$TZ \leftarrow countr\_zero(C)$\;
	$C' \leftarrow ashr(C, TZ)$\;
	
	\eIf{$C' > 0$}{
		\eIf{$(C' - 1)$ is power of two}{
			Rewrite as $(x \ll \log_2(C'-1)) + x$\;
		}{
			\If{$(C' + 1)$ is power of two}{
				Rewrite as $(x \ll \log_2(C'+1)) - x$\;
			}
			\Else{\Return fail\;}
		}
	}{
		\eIf{$(-C' + 1)$ is power of two}{
			Rewrite as $x - (x \ll \log_2(-C'+1))$\;
		}{
			\If{$(-C' - 1)$ is power of two}{
				Rewrite as $-( (x \ll \log_2(-C'-1)) + x )$\;
			}
			\Else{\Return fail\;}
		}
	}
	
	\Return success\;
\end{algorithm}


\subsubsection{3.重写阶段}
在重写阶段，编译器根据匹配到的常量形式，生成对应的移位与加减指令序列，并替换原有的G\_MUL指令。


%*********************************************************************
% 3.4 本章小结
%*********************************************************************
\section{本章小结}
本章主要分析并设计了面向DSP架构的全局指令选择优化策略。首先，针对GlobalISel框架在DSP后端的性能瓶颈，提出了包括CSE、KnownBits Analysis和Combiner等技术的优化方案，旨在减少冗余指令，提升代码执行效率和硬件利用率。通过对这些优化技术的理论基础和实现机制进行详细分析，揭示了优化策略在不同阶段的应用方式。

\par

在具体优化技术分析中，介绍了CSE如何通过消除重复计算、减少寄存器占用来精简代码，已知位分析如何为常量传播和指令简化提供支持，合并优化则通过删除冗余指令、重构指令序列，提高代码密度和执行效率。此外，本章还针对DSP架构的特点，设计了符合目标架构需求的优化策略，如立即数装载优化和乘法优化，以进一步提升指令生成效率和硬件资源利用率。

\par

最后，本章通过系统的优化设计与实现，展示了如何通过多策略协同来提升全局指令选择框架在DSP架构下的代码生成性能，为后续的代码生成与优化工作奠定了坚实的基础。
