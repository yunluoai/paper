\chapter{面向DSP的全局指令选择实现}


%*********************************************************************
% 2.1 全局指令选择框架概述
%*********************************************************************
\section{全局指令选择框架概述}
编译器后端指令选择阶段的工作是将LLVM IR（Intermediate Representation，中间表示）转换为目标架构MI（Machine Instruction，机器指令）。这一阶段所要解决的问题是在保持程序语义不变的基础上生成适用于目标架构的指令序列。这个过程对生成的目标代码质量、资源利用率以及编译器对各种复杂硬件架构的兼容性有很大影响，是连接前后端的重要纽带。

\par

随着处理器架构的不断发展以及LLVM编译器基础设施的不断成熟，指令选择的实现方式也在不断变化。出于不同应用场景及性能要求的考虑，LLVM演变出不同的指令选择实现方案，先后引入了快速指令选择、基于有向无环图的指令选择以及全局指令选择这3个指令选择实现技术路线。这3种指令选择方案在设计思路、适用性以及代码生成质量特点上各有侧重。


% 2.1.1 传统指令选择方案及其局限性
\subsection{传统指令选择方案及其局限性}
在LLVM的早期发展阶段，指令选择的目标是保证LLVM IR能够正确、稳定地映射为目标架构支持的机器指令，并在开启优化选项时能生成质量较高的代码。为此LLVM采用了基于DAG的指令选择方案。该方案是LLVM长期以来的主流指令选择方案，也是高优化等级下的默认指令选择方案。该方案支持复杂架构指令集，能够处理X86、ARM以及RISCV等各种架构复杂的指令选择需求。


\par

基于DAG的指令选择方案通过将基本块内的LLVM IR转换为SelectionDAG，对SelectionDAG进行指令合法化、节点合并以及指令匹配替换等操作，从而实现中间表示转成对应机器指令的映射过程。方案的整体处理流程如图\ref{fig:dag_flowchart}所示。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/dag_flowchart.png}
	\caption{SelectionDAGISel流程图}
	\label{fig:dag_flowchart}
\end{figure}


SelectionDAGISel的设计思路是将LLVM IR转换成DAG来表示指令间的数据流依赖关系，然后再通过模式匹配和树覆盖的方法来将DAG内的节点转换为目标架构的机器指令。SelectionDAGISel的执行过程分为三个阶段：第一阶段，框架将LLVM IR指令序列转为SelectionDAG。在DAG图中每个节点表示一种操作，边表示数据依赖，能直观地看到指令之间的数据流依赖关系，不再需要对指令进行线性的扫描；第二阶段，为了简化后续的匹配流程，框架对SelectionDAG进行标准化操作及优化；第三阶段，框架采用基于TableGen自动生成的模式匹配器，对优化后的SelectionDAG进行拓扑排序，通过自底向上遍历节点来匹配目标架构在td文件中定义的DAG模式，之后将匹配成功的节点替换为对应的机器指令，最终生成目标架构的机器代码。图\ref{fig:dag_example}展示了一个简单自增运算函数在指令选择阶段生成、调度之前的部分SelectionDAG图。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{pics/dag_example.pdf}
	\caption{自增运算函数在指令选择阶段生成的部分SelectionDAG示例}
	\label{fig:dag_example}
\end{figure}

利用SelectionDAG结构，SelectionDAGISel可以实现对全局数据流进行详细分析，能够对指令进行比较复杂的优化、合成，并能提高生成代码的质量。此外，开发者仅需在描述文件中定义指令模式就可以自动生成匹配代码，大大降低新架构的适应开发成本。但是这种指令选择方案的设计比较复杂，这是因为SelectionDAG的构造、优化、拓扑排序等都需要比较复杂的逻辑，并且DAG与LLVM IR及机器指令之间的转换也需要额外的转化层，增加了设计的复杂度。

\par

而随着LLVM编译器生态的发展，LLVM因其模块化的特征、良好的跨平台兼容性等特点，在各种大型工业软件开发、复杂代码调试和维护等场景中得到了广泛应用。在这样的背景下，低优化等级下快速地编译代码成为了关键诉求。为了满足项目调试构建过程快速编译的这一需求，LLVM在原来的SelectionDAGISel框架之外引入了FastISel框架。FastISel是LLVM为平衡编译速度与代码质量设计的轻量级指令选择方案，FastISel的核心定位是优先考虑编译速度，同时兼顾基础指令选择需求，其主要用于O0优化等级下的代码生成。

\par

从设计原理来看，快速指令选择采用线性扫描+模式匹配的策略，以单个指令为处理单位，不构建复杂的中间表示结构。其核心流程为：遍历LLVM IR指令序列，对每条指令直接匹配目标架构的简单指令模式，匹配成功则直接生成机器指令，匹配失败则回退到基于DAG的指令选择。该流程如图\ref{fig:fast_flowchart}所示。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.7\textwidth]{pics/fast_flowchart.png}
	\caption{FastISel流程图}
	\label{fig:fast_flowchart}
\end{figure}

为了提高编译速度，快速指令选择采用手写C++代码的方式来实现匹配规则。这种方式能够有效地避免TableGen工具的解析、代码产生所带来的额外成本，也避免了指令间的依赖分析以及复杂的优化逻辑。使用快速指令选择的编译效率非常高，在调试模式下能大幅度减少编译的时间，但FastISel也有局限性。因为只有简单指令模式的匹配，无法匹配比较复杂的指令模式（如向量运算、指令融合等等），导致生成的代码质量较低。

\par

除此之外，FastISel缺乏全局视角，无法做跨指令的数据流和控制流优化，在性能敏感的场合无法满足性能要求。所以快速指令选择只能作为一种调试的默认模式，仅适合用来调试和快速编译，在对性能敏感的优化阶段仍然需要更强的指令选择机制。

\par

近些年来，编译器的应用领域不断拓展，这些传统指令选择方案无论是在编译速度，还是在架构独立性上都难以适应新的应用需求。具体而言，SelectionDAGISel的复杂中间表示及其相应优化机制增加了编译流程的复杂性和维护的负担，以及由于SelectionDAGISel的局部作用域的特性，SelectionDAGISel在处理基本块间复杂优化等复杂情况下存在着明显的不足。这些问题推动了新一代指令选择机制的产生和发展。


% 2.1.2 全局指令选择原理及框架设计
\subsection{全局指令选择原理及框架设计}
全局指令选择是LLVM为突破基于DAG的指令选择框架的局限性而推出的全新指令选择方案。全局指令选择的核心目标在于平衡编译速度、代码质量以及架构适配的灵活性，并且通过统一的流程实现从LLVM IR到机器指令的转换。

\par

从设计理念来看，全局指令选择摒弃了基于DAG的专用中间表示，转而使用GMIR（Generic Machine Intermediate Representation，通用机器中间表示）作为其核心载体。GMIR本质上是对LLVM IR的轻量级扩展，在保留了LLVM IR的语义特征的同时引入了目标架构的基础信息，这使得在指令选择的过程无需在多种中间表示间进行频繁转换，从而简化了整体流程。

\par

GlobalISel的核心优势是全局性和灵活性。全局性体现在GlobalISel是以函数为粒度的，结合全局的控制流和数据流，用全局视角进行指令选择，所以GlobalISel可以对一个基本块内部的指令序列进行优化；而灵活性是指GlobalISel具备手动和自动两种模式进行匹配，在自动模式下除了可以根据TableGen进行匹配外，还可以重用基于DAG的指令选择的那部分对指令集的描述信息，这样前期的设计工作量会大大降低。

\par

全局指令选择的执行流程分为两个核心阶段：第一阶段为GMIR预处理，包括将LLVM IR转换为原始GMIR、指令合法化、寄存器类型选择，最终生成附着目标架构信息的合法GMIR；第二阶段为机器指令选择，以函数为粒度，采用基于树覆盖的指令选择算法，通过自动匹配模块和手动匹配模块，将GMIR指令树映射为MIR（Machine Intermediate Representation，目标架构的机器中间表示），同时将通用虚拟寄存器限制到具体的寄存器类中，并传递COPY指令至后续的寄存器分配阶段。

\par

全局指令选择将两个阶段涉及的每个功能都拆分成独立的Pass，这样既能使整体的架构更加清晰，也能够方便利用LLVM Pass的相关基础设施进行代码维护和问题分析定位。LLVM实现中将全局指令选择所必需的基本功能划分为4个Pass，其中第一阶段包含3个Pass，而第二阶段为1个Pass。还有窥孔类的优化也会以独立Pass进行实现，并可以放置在4个基础Pass之间的任意位置，不同的架构可以根据需要配置一到多个这种优化Pass。该流程如图\ref{fig:global_flowchart}所示。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/global_flowchart.png}
	\caption{GlobalISel流程图}
	\label{fig:global_flowchart}
\end{figure}

相比于前两种指令选择方案，GlobalISel实现了在编译效率、代码质量和架构适配性之间的多维度平衡。从编译速度的角度来看，GlobalISel摒弃了SelectionDAG中复杂的处理流程，编译效率接近快速指令选择；从代码质量的角度来看，凭借其全局视角和复杂模式的匹配能力，GlobalISel能够生成与基于DAG的指令选择相当的高质量代码；从架构适配性的角度来看，GlobalISel的模块化设计使其能更方便地扩展和维护，由于GlobalISel采用通用的GMIR表示和灵活的模式匹配方式，使其更容易地适配新架构，尤其是包含特殊寄存器组或独特指令集的架构。


%*********************************************************************
% 2.2 GMIR生成
%*********************************************************************
\section{GMIR生成}
GMIR的生成是GlobalISel第一阶段的第一个Pass，也称为IRTranslator。IRTranslator阶段的任务是完成LLVM IR到GMIR的语义下沉与架构适配，核心是要完成寄存器处理、栈管理以及调用约定处理等操作。IRTranslator的实现以DSP目标平台的ABI（Application Binary Interface，应用二进制接口）约定、指令集特性及数据类型支持为核心依据，通过模块化的调用处理机制，确保函数调用、参数传递、返回值处理的正确性与高效性。


% 2.2.1 通用机器表示
\subsection{通用机器表示}
GMIR是GlobalISel的中间层表示，在LLVM IR与目标机器强相关的MIR之间起到承上启下的作用。GMIR的设计目标之一就是在保留通用机器语义的同时延迟引入具体架构细节，这样的好处是可以为跨平台指令选择、合法化以及后继的优化提供统一而稳定的基础。通过这一设计，GlobalISel能够在更大作用域内进行分析与决策，避免过早绑定目标架构而减少优化空间。GMIR由四个要素组成：

\begin{enumerate}
	\item
	通用虚拟寄存器（Generic Virtual Register）：不绑定具体物理寄存器，由MachineRegisterInfo统一管理生命周期，是GMIR中数据传递的核心载体，如函数参数、运算结果均存储于虚拟寄存器。
	
	\item
	通用指令集（Generic Instructions）：覆盖算术运算、逻辑运算、内存访问、分支跳转、函数调用与返回等基础操作，指令格式标准化，避免架构专属指令的碎片化。
	
	\item 
	LLT（Low-Level Type，低级别类型）：基于位宽和类型类别定义（如标量、指针、向量），摒弃了LLVM IR的高级类型（如结构体、类），更贴近硬件数据处理逻辑。
	
	\item 
	架构约束元数据：通过MachineMemOperand（内存访问属性）、RegMask（寄存器掩码）、CCValAssign（调用约定分配信息）等属性来系统化地表示目标架构的各种约束。
	
\end{enumerate}

在GlobalISel整体流程内，GMIR存在于指令选择前后的多个关键阶段。IRTranslator以函数为单位去遍历LLVM IR，把它直接映射成GMIR的通用指令和虚拟寄存器表示。在这一阶段，编译器可结合目标架构展开必要的特化处理，比如说DSP架构会对64位浮点运算进行拆分，而后进入到合法化阶段，框架要对GMIR里目标架构不直接支持的指令及参数类型修正，保证其完全在硬件能力范围之内。在寄存器组选择阶段，框架把通用虚拟寄存器映射到目标架构定义的寄存器组当中，为后续的物理寄存器分配奠定基础。在指令选择阶段，框架会把GMIR的通用指令替换成目标架构的机器指令，最终生成与目标硬件紧密绑定的MIR表示。为进一步明确GMIR在LLVM编译流程中的抽象层级及其过渡性定位，表\ref{tab:ir_gmir_mir}对LLVM IR、GMIR与MIR在抽象层级、核心元素及架构相关性等方面进行了对比。

\begin{table}[htbp]
	\centering
	\caption{LLVM 不同中间表示层次对比}
	\label{tab:ir_gmir_mir}
	
	\renewcommand{\arraystretch}{1.2}
	{\footnotesize
		\begin{tabularx}{\linewidth}{
				>{\raggedright\arraybackslash}m{1.2cm}
				>{\centering\arraybackslash}X
				>{\centering\arraybackslash}X
				>{\centering\arraybackslash}X
				>{\centering\arraybackslash}X
			}
			\toprule
			类型 & 抽象层级 & 核心元素 & 架构相关性 & 核心作用 \\
			\midrule
			IR &
			高级语言无关抽象（函数、模块级） &
			函数、基本块、Value、LLVM IR 指令 &
			完全无关 &
			跨平台程序分析与中端优化 \\
			
			GMIR &
			通用机器语义抽象（指令、寄存器级） &
			通用虚拟寄存器、通用指令、LLT 类型 &
			部分相关 &
			衔接 LLVM IR 与架构相关 MIR，统一指令选择流程 \\
			
			MIR &
			目标架构专属抽象（硬件指令、物理寄存器级） &
			物理寄存器、目标架构指令、硬件约束 &
			完全相关（绑定具体硬件） &
			目标架构指令调度与寄存器分配 \\
			\bottomrule
		\end{tabularx}
	}
\end{table}

与SelectionDAGISel中LLVM IR到SelectionDAG的映射流程相比，GlobalISel的LLVM IR到GMIR的映射过程更加简单，语义更加完整，优化机会也更多。这个过程省掉了SelectionDAG流程中LLVM IR、SelectionDAG以及MachineDAG多次转换过程所带来的繁琐和开销，编译过程非常简单。同时，GMIR以函数粒度生成，能够保留LLVM IR中不同基本块之间的控制流和数据相关依赖信息的完整性，为函数级优化创造机会。另外，通用虚拟寄存器会跨基本块存在，LLT又对异构类型系统比较友好，这使得GMIR在更大范围内起作用，为跨基本块的指令合并、全局寄存器分配等任务提供支撑。


% 2.2.2 GMIR生成方法
\subsection{GMIR生成方法}
GMIR的指令分为两类：架构无关指令和架构相关指令，这样做的好处在于既保留了通用优化的灵活性，又能通过架构特化逻辑适配不同硬件的底层约束。其中，架构无关指令包括算术指令、逻辑指令等，因为这类指令只表达通用机器的语义，不依赖于特定的硬件，故可以用GlobalISel统一生成；而架构相关指令主要是针对于硬件约束较强的指令操作，如函数调用、形式参数处理等操作。架构相关指令所依赖的ABI调用约定（即相应的寄存器约定、栈帧约定、参数传递约定等）是特定于目标机器的，所以必须有针对性地实现各种指令。

\par

IRTranslator是LLVM IR到GMIR的翻译器，负责对所有指令翻译过程进行协调和调度。GlobalISel中IRTranslator以函数为单位对LLVM IR中的每个指令进行遍历，将这些指令转换成对应的通用机器指令表示，进而完成将高级IR译码为通用机器语义的过程。

\par

在翻译过程中，IRTranslator的模块化特性避免它直接处理目标架构强相关的细节，将函数调用之类的使用ABI约定的细节留给目标后端去处理。其中CallLowering是IRTranslator的核心，包括了参数传递、返回值处理等调用约定的细节处理。IRTranslator在处理函数的入口、调用指令以及返回指令时，通过统一的接口调用目标后端的CallLowering来处理函数的常规翻译，从而实现通用翻译框架与目标架构定制的业务解耦。

\par

基于这种分层协作机制，GlobalISel能够在保持IRTranslator通用性的同时，还能实现对不同目标架构ABI差异的良好适配，从而实现通用指令翻译逻辑与目标架构定制逻辑之间的有效解耦。IRTranslator与CallLowering之间的关系及协作方式如图\ref{fig:irtranslator_call}所示。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.5\textwidth]{pics/irtranslator_call.png}
	\caption{GMIR生成流程图}
	\label{fig:irtranslator_call}
\end{figure}

以函数调用约定处理为例，在函数调用的过程中需要将LLVM IR中抽象的函数调用、参数传递语义，转换为符合目标架构规范的GMIR。由于不同架构的寄存器布局、栈对齐要求、参数存储优先级（寄存器优先或栈优先）存在显著差异，因此需要由各目标架构单独实现专属的CallLowering模块，模块通过解析自身的ABI约定来完成LLVM IR到GMIR的精准映射，从而确保后续指令选择与硬件执行的兼容性。

\par

GMIR生成的执行过程是以函数为粒度进行的，与SelectionDAGISel是以基本块为粒度不同，由于函数可以分为包含形参信息的函数头与函数体，函数体又有基本块等表示，所以按处理的函数信息不同，将执行过程分为4个主要的阶段，如图\ref{fig:gmir_gen_flowchart}所示。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.7\textwidth]{pics/gmir_gen_flowchart.png}
	\caption{GMIR生成流程图}
	\label{fig:gmir_gen_flowchart}
\end{figure}

\begin{enumerate}
	\item
	创建基本块：这个阶段会遍历函数的LLVM IR基本块，依次为每个基本块创建对应的GMIR的基本块，并且会保留相关的控制流信息，形成初始的控制流图。还会为每个函数添加一个额外的基本块（EntryBB），作为函数入口。
	
	\item
	处理形参：根据目标架构的调用约定规则处理函数的入参，为每个入参生成一条从传参寄存器复制到虚拟寄存器的GMIR复制指令，或者为入参生成一条从栈上加载到虚拟寄存器的GMIR加载指令，并将生成的指令放入EntryBB中。
	
	\item 
	转换函数体指令：按RPOT（Reverse Post-Order Traversal，逆后序遍历）的方式遍历函数的控制流图，对于每个基本块，以自顶向下的顺序将基本块里的每条指令转换成一组GMIR指令。
	
	\item 
	更新控制流图：在第3阶段的指令转换过程中，有些原本不是跳转的指令会被翻译成跳转指令（例如，跳转指令的条件码是由多条连续的逻辑运算指令生成的，此时就有可能会拆分逻辑运算生成多个跳转指令），导致原有基本块被拆分出多个新基本块，破坏原有的控制流。因此在基本块指令转换好后，需要维护好这些新基本块与原有基本块的控制流边，形成新的控制流图。此外，转换过程还可能会将EntryBB和函数体中的第一个基本块合并，此时控制流信息也要跟着更新。
	
\end{enumerate}


% 2.2.3 GMIR生成实现
\subsection{GMIR生成实现}
根据2.2.2节设计可知，GMIR的指令生成逻辑分为架构无关和架构相关两类。算术运算、逻辑运算等架构无关指令的处理由框架统一实现。与DSP结构强绑定的函数调用、函数参数、结果值等架构相关指令的处理需要根据DSP的ABI、寄存器布局以及数据传输等特性来对CallLowering进行定制化开发。对于DSP结构来说，以上这些场景之间都会在寄存器宽度、类型支持、端序等方面有较大差异，因此也是IRTranslator实现的重点和难点。

\par

为适配DSP的特性，本文基于ValueHandler接口实现了DSPIncomingValueHandler和DSPOutgoingValueHandler两个辅助类，这两个辅助类分别负责函数入参数出参数的传递、函数返回值的返回，类的结构如图 \ref{fig:valuehandler}。这一设计将参数与函数返回值的相关处理从IRTranslator主流程中分离出来，可以让调用相关的架构特化代码能够集中被管理，有效地提高了可维护性和可扩展性。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.7\textwidth]{pics/valuehandler.png}
	\caption{DSPValueHandler核心函数}
	\label{fig:valuehandler}
\end{figure}

\begin{enumerate}
	\item
	getStackAddress用于生成DSP架构下栈帧空间的目标地址虚拟寄存器，根据上下文选择基于帧索引还是直接操作栈指针，为出参的栈上存储提供地址支持。
	
	\item
	assignValueToReg用于将目标值分配至物理寄存器，核心完成COPY指令构建，并按需标记虚拟寄存器的状态属性。
	
	\item 
	assignValueToAddress用于完成栈上数据的加载和存储，将其加载或存储在合适的位置并在需要时进行扩展。
	
	\item 
	assignCustomValue是针对DSP架构的定制化实现，采用数据的合并、拆分算法解决非法类型跨函数传入的情况。例如，函数根据DSP的端序特性调整高低位数据的存储顺序，保证了跨函数的属性一致性。除此之外，函数会利用G\_COPY指令将拆分的数据寻址映射到目标物理寄存器上。
	
\end{enumerate}

在具体的实现中，IRTranslator需要分别完成函数调用、形式参数以及返回值的降级处理等操作。其中，以lowerCall为例，其主要流程可概括为以下几个阶段：

\begin{enumerate}
	\item
	调用合法性校验：约束调用约定（如DSP仅支持C语言调用约定），确保跨函数调用的二进制兼容性；校验入参和返回值类型是否为架构支持的类型，提前拦截非法调用以避免后续流程异常。
	
	\item
	栈帧预处理与调用指令构建：lowerCall会先生成栈帧调整的起始指令，为调用过程预留所需的栈空间；随后根据被调用者的类型动态选择合适的调用指令，并将被调用者标识附加到调用指令中，从而为后续指令选择阶段提供明确的目标地址信息。
	
	\item 
	出参传递与栈空间校准：lowerCall对参数按DSP数据类型规则进行拆分，生成适配DSP结构的ArgInfo列表，再结合DSPCCState和参数调用规则ABI，解析参数的寄存器/栈分配规则，由DSPOutgoingValueAssigner给出分配值的具体计算和参数传递。最后获取DSP结构栈对齐的要求，将栈空间的大小按对齐要求校准，使栈访问符合硬件约束。
	
	
	\item 
	调用指令提交与间接调用约束：lowerCall将构建完成的调用指令（CALL/CALLR）插入当前基本块，若为CALLR指令，通过constrainAllUses结合DSP的RegisterBank信息及目标指令信息，约束指令操作数的合法性，避免跨银行访问或非法寄存器使用。
	
	\item 
	返回值处理与栈帧恢复：若返回值不为空，lowerCall则利用DSPIncomingValueAssigner解析出返回值分配策略，将物理返回值寄存器的值映射到通用虚拟寄存器，将栈指针恢复并释放调用过程占用的栈空间，从而完成整个调用流程。	
	
\end{enumerate}

上述IRTranslator的实现在DSP架构下实现了完整的函数调用、参数传递和返回等机制，解决了通用CallLowering逻辑在寄存器宽度和非法类型处理上的不足的问题，保证了语义正确性，也为后续指令合法化和指令选择阶段提供了清晰明确的中间表示基础。


%*********************************************************************
% 2.3 指令合法化
%*********************************************************************
\section{指令合法化}
在经过IRTranslator阶段的转换后，以LLVM IR表示的函数已经转变成了GMIR表示的函数。这一转换并非简单的语法映射，而是伴随语义适配的深度处理。为了衔接后续架构适配流程，IRTranslator会在转换过程中嵌入部分目标架构的如寄存器组初步约束、调用约定相关标记等基础信息。但从设计本质来看，GMIR作为通用机器中间表示的核心属性并未改变，转换生成的绝大多数GMIR指令仍保持架构无关性，这种设计虽保障了跨架构复用性，但这也必然导致一个核心问题：部分GMIR指令可能超出目标架构的硬件能力范围，成为非法指令，即有部分GMIR指令会存在目标架构不支持的情况。

\par

非法GMIR指令的产生源于架构能力的固有差异，最典型的场景便是数据位宽不匹配。例如，针对16位字长的嵌入式架构，其硬件指令集仅支持16位或32位运算，若IRTranslator因LLVM IR中原有的64位数据运算生成了64位的G\_ADD指令，该指令便会因超出硬件处理能力而成为非法指令。类似地，部分架构不支持向量运算或特定类型的内存访问，对应的GMIR向量指令、特殊寻址模式指令也会被判定为非法。

\par

为解决非法GMIR指令的问题，框架需要实现一个独立的合法化Pass，这个Pass是衔接GMIR与目标架构特性的关键枢纽。该Pass的工作原理是首先加载目标架构的完整指令集描述信息，涵盖其支持的数据类型、运算操作以及寄存器约束等关键元数据，随后以函数为单位遍历GMIR代码，将其中所有非法指令逐一替换为语义等价的合法GMIR指令序列，从而使生成的指令组合能够完全适配目标架构的硬件能力。


% 2.3.1 指令合法化方法
\subsection{指令合法化方法}
合法化过程以函数为基本粒度，采用结构化遍历的执行逻辑，从而确保指令转换结果的完整性与正确性。在遍历策略上，Pass采用RPOT算法自函数入口开始依次扫描所有基本块，该遍历顺序能够保证父基本块中的指令优先于子基本块被处理，从而有效避免由控制流分支依赖引发的转换冲突。在进入单个基本块之后，指令按照自顶向下的顺序逐条处理，对每一条GMIR指令进行合法性检查，一旦发现非法指令，立即触发相应的转换逻辑。待当前基本块内所有指令均完成合法化后，再继续处理下一个基本块，直至整个函数范围内的GMIR指令全部完成合法化。

\par

指令合法化的处理过程实际上包含了两个关键子问题的处理，二者共同构成了指令合法化的完整技术链路：

\begin{enumerate}
	\item
	非法指令识别：Pass通过查询目标架构提供的LegalizerInfo接口来进行判断。一方面需要判断校验指令操作码与数据类型的组合是否支持，如G\_ADD指令是否支持64位数据。另一方面需要检查指令的操作数约束是否符合架构的要求。例如，针对ARM架构的LegalizerInfo会明确标记G\_FADD（浮点加法）仅支持32位和64位，若GMIR中出现16位浮点加法指令，则会被Pass直接判定为非法。此外，部分架构对指令的隐含约束也会纳入识别逻辑，用于确保识别结果的精准性。
	
	\item
	非法指令转换：当检测到非法指令时，Pass需要通过指令重构来生成一组语义不变且实现架构兼容合法指令序列。由于非法指令产生原因不同，转换策略通常可分为两类。针对数据位宽不匹配的情形，采用拆分与重组相结合的方法，例如将64位的G\_ADD运算拆解为两个32位G\_ADD指令，并通过进位标志的传递实现语义等价的计算。对于目标架构不支持的操作类型，如在缺乏硬件除法单元的体系结构上遇到G\_SDIV指令，则通过算法模拟的方式加以替代，利用减法、移位等基础指令组合实现相同的除法语义。除此之外，在整个转换过程中还必须同步完成虚拟寄存器类型的调整以及指令间依赖关系的维护，从而确保重构后的指令序列在数据流和执行效果上与原始指令保持一致。
	
\end{enumerate}

在上述两个子问题得到解决后，合法化Pass最终实现了GMIR从通用到架构适配的关键转换。这为后续的寄存器组选择以及目标指令生成等流程提供了合法且可靠的输入基础。


% 2.3.2 指令合法化实现
\subsection{指令合法化实现}
根据2.3.1的设计，合法化阶段的目标是非法指令的识别与非法指令的转化。在具体实现上，合法化流程首先需要明确目标架构所支持的LLT类型集合，该集合不仅包括各类数据类型，还包括地址类型与内存访问相关的类型信息。上述类型集合构成了指令合法性判定的基础边界，用以描述目标架构在位宽支持、对齐约束以及寻址能力等方面的硬件限制。

\par

在此基础上，需要构建一组合法化规则集，用于对GMIR指令进行系统化的合法性判定与处理策略选择。LegalityQuery对象是规则集的核心载体，该对象通过结构化封装的方式，将合法性判定所需的关键信息统一组织为标准数据结构。具体包括指令操作码、各操作数索引对应的LLT类型、MachineMemOperand中描述的内存访问字节大小，以及针对内存类指令的原子性与顺序约束等信息。DSP架构的部分合法化规则集如下所示。

\lstset{language=c++}
\begin{lstlisting}
DSPLegalizerInfo::DSPLegalizerInfo(const DSPSubtarget &ST)
		: STI(ST), XLen(STI.getXLen()), SXLen(LLT::scalar(XLen)) { 
	const LLT S1 = LLT::scalar(1);
	const LLT S8 = LLT::scalar(8);
	const LLT S16 = LLT::scalar(16);
	const LLT S32 = LLT::scalar(32);
	const LLT S64 = LLT::scalar(64);
	const LLT P0 = LLT::pointer(0, 32);
	const LLT SDoubleXLen = LLT::scalar(2 * XLen);
	......
		
	auto &ShiftActions = getActionDefinitionsBuilder({G_ASHR,G_LSHR,G_SHL});
	if (ST.is64Bit())
		ShiftActions.customFor({{S32, S32}});
	ShiftActions.legalFor({{S32, S32}, {S32, SXLen}, {SXLen, SXLen}})
		.widenScalarToNextPow2(0)
		.clampScalar(1, S32, SXLen)
		.clampScalar(0, S32, SXLen)
		.minScalarSameAs(1, 0);
		......
\end{lstlisting}

这种设计在工程实践中具有明显的优势。一方面，其他编译Pass可直接基于LegalityQuery对象查询指令合法性，而无需重复解析指令内部结构，从而有效地降低实现复杂度。另一方面，合法性判定过程不依赖于实际指令实例的构造，这样做的好处是能够避免额外的对象创建与析构开销，在提升编译效率的同时，也使LegalityQuery对象能够直接作为谓词约束的输入参数，支撑更为复杂和精细的合法性判断逻辑。

\par

合法化规则集的生成与执行遵循统一的标准流程。通过调用getActionDefinitionsBuilder接口，可为指定操作码构建专属的合法化规则集。当输入多个操作码时，该接口会自动将其绑定至同一规则集中，适用于操作语义相近、合法化策略一致的指令类型。规则集中的各条规则按照自上而下的优先级顺序依次匹配，当某条指令成功匹配并完成合法性判定后，其后续处理即告结束，下一条指令将重新从规则集起始位置开始匹配，从而保证每条指令都能获得唯一且确定的合法化结果。

\par

如果某条指令未匹配到任何规则，则会被直接判定为合法化失败。当规则集中未显式声明指令为合法时，系统将自动触发类型扩展、拆分或重写等数据类型转换逻辑，为后续指令选择阶段提供可执行的中间表示基础。通过这种机制，合法化阶段能够在保持规则清晰性的同时，兼顾灵活性与健壮性。

\par

对于一些合法化逻辑复杂的指令，框架提供的标准化的规则集往往不足以无法完成目标架构适配，因此需要实现自定义合法化函数legalizeCustom来承载专有的合法化逻辑。与此同时，对于架构强相关的内建函数，还需要额外实现legalizeIntrinsic的处理入口，以完成对应内建函数的合法化。以G\_VASTART指令为例，该指令用于在可变参数函数中标记可变参数的起始位置，其合法化过程通常需要通过legalizeCustom实现定制化转换，将通用的G\_VASTART语义映射为DSP架构可执行的内存存储序列，并显式体现与栈帧布局相关的约束关系。相关实现代码如下所示。

\lstset{language=c++}
\begin{lstlisting}
bool DSPLegalizerInfo::legalizeVAStart(MachineInstr &MI,
		MachineIRBuilder &MIRBuilder) const {
	assert(MI.getOpcode() == TargetOpcode::G_VASTART);
	MachineFunction *MF = MI.getParent()->getParent();
	DSPMachineFunctionInfo *FuncInfo = MF->getInfo<DSPMachineFunctionInfo>();
	int FI = FuncInfo->getVarArgsFrameIndex();
	LLT AddrTy = MIRBuilder.getMRI()->getType(MI.getOperand(0).getReg());
	auto FINAddr = MIRBuilder.buildFrameIndex(AddrTy, FI);
	assert(MI.hasOneMemOperand());
	MIRBuilder.buildStore(FINAddr, MI.getOperand(0).getReg(), *MI.memoperands()[0]);
	MI.eraseFromParent();
	return true;
}
\end{lstlisting}


%*********************************************************************
% 2.4 寄存器组选择
%*********************************************************************
\section{寄存器组选择}
虽然指令合法化阶段引入了目标架构的指令信息，并将GMIR生成阶段生成的GMIR转换为符合目标架构约束的合法GMIR，但此时的GMIR指令仍然没有具体的寄存器分配信息。指令里的虚拟寄存器操作数仅携带用于表示其类型和位数大小的数据类型描述。因此，全局指令选择模块需要进一步为GMIR中的虚拟寄存器确定其可映射的寄存器组类型，即完成寄存器组选择过程。

\par

寄存器组选择是全局指令选择模块的第三个基本Pass，它会利用目标架构的寄存器信息，自顶向下的为合法化后的GMIR指令中的虚拟寄存器操作数分配合适的寄存器组类型，并且它还可以利用GMIR指令之间的关系选取一个较优的寄存器组类型。这也是不能直接在GMIR生成处理中为直接分配寄存器类型的原因之一：在GMIR生成阶段生成指令时，LLVM IR还没有全部转换成GMIR，无法利用指令之间的关系进行寄存器类型择优。


% 2.4.1 寄存器组
\subsection{寄存器组}
在GlobalISel框架中，Register Bank（寄存器组）是目标架构层面的关键抽象组件，其设计目标是在满足硬件指令访问约束的前提下，通过弱约束分组机制平衡寄存器分配的灵活性与跨寄存器资源的数据交互开销，从而兼顾编译效率与生成代码性能。与传统编译器的Register Class（寄存器类）不同，Register Bank仅关注寄存器的最大数据宽度及支持的操作集合，而不对具体物理编号和精确位宽做强约束，这使得编译器在分配阶段拥有更大的选择空间。

\par

寄存器组的提出源于硬件架构的实际限制。许多嵌入式处理器、DSP及异构计算平台将物理寄存器划分为多个相互独立的寄存器文件，不同文件之间的寄存器无法被同一条指令同时访问。若操作数分布在不同寄存器文件中，必须通过额外的数据复制指令完成中转，从而引入不必要的性能开销。寄存器组通过将物理寄存器按文件属性进行逻辑分组，使编译器能够在寄存器分配阶段优先将关联变量分配到同一寄存器组中，从源头减少跨文件数据复制。

\par

在实际架构中，寄存器组通常与运算单元类型紧密对应，例如通用寄存器组（GPR）和浮点寄存器组（FPR）。GMIR 指令在寄存器组使用上遵循硬性约束+柔性适配的原则：一方面，特定指令必须使用指定寄存器组（如浮点运算只能使用 FPR）；另一方面，部分指令允许在多个寄存器组间灵活分配，其最终选择由后续运算需求决定，从而避免不必要的跨组数据复制。该弱约束设计不仅降低了寄存器分配复杂度，也显著减少了跨寄存器文件的数据搬运开销，尤其适合嵌入式与DSP等资源受限架构。同时，寄存器组的抽象方式具有良好的扩展性，新架构仅需在目标描述中定义寄存器组属性即可完成适配，无需修改编译器核心逻辑。表\ref{tab:reg_type_class}列出了DSP架构下使用的寄存器组与寄存器类划分情况，为后续寄存器银行选择与物理寄存器分配过程提供基础。

\begin{table}[htbp]
	\centering
	\caption{DSP架构下寄存器抽象类型与分类}
	\label{tab:reg_type_class}
	
	\renewcommand{\arraystretch}{1.2}
	{\footnotesize
		\begin{tabularx}{\linewidth}{
				>{\raggedright\arraybackslash}X
				>{\raggedright\arraybackslash}X
			}
			\toprule
			\textbf{寄存器抽象层级} & \textbf{具体实例} \\
			\midrule
			Register Bank &
			GPRBRegBank、CRBRegBank、VPRBRegBank \\
			
			Register Class &
			GPR32EVEN、GPR32、GPR64、VTRegs、OBMRegs、VPR4Out、VPR8Out、VPR16Out、VPRSf、VPRHf 等 \\
			\bottomrule
		\end{tabularx}
	}
\end{table}


% 2.4.2 寄存器组选择方法
\subsection{寄存器组选择方法}
寄存器组选择阶段的核心任务是在合法化完成之后，为GMIR指令中引入的虚拟寄存器操作数分配合适的寄存器组，从而确保后续指令选择与物理寄存器分配过程能够满足目标架构的硬件访问约束。在DSP目标架构下，寄存器组选择模块的整体设计结构如图\ref{fig:registerbankinfo_class}所示。该模块主要由DSPGenRegisterBankInfo与DSPRegisterBankInfo两部分构成：前者由TableGen根据DSPRegisterBanks.td文件自动生成，负责描述目标架构中可用的寄存器组及其基础属性；后者则作为目标后端的核心实现类，封装了寄存器组选择所需的全部元信息与决策逻辑，包括指令到寄存器组的映射规则、操作数属性以及不同映射方案之间的代价评估。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{pics/registerbankinfo_class.png}
	\caption{DSP 架构下寄存器组选择模块结构}
	\label{fig:registerbankinfo_class}
\end{figure}


% 2.4.3 寄存器组选择实现
\subsection{寄存器组选择实现}
基于上一节对寄存器组选择机制的设计分析，本节将从寄存器组定义、映射结构定义及映射逻辑实现三个核心维度，详细阐述DSP架构编译器后端寄存器组选择功能的具体实现方案。

1.寄存器组的定义

DSP处理器内部包含了多种不同类型的寄存器，不同寄存器在位宽、用途及访问方式上存在显著差异。为保证寄存器分配与硬件执行语义的一致性，需要首先对目标架构中可参与寄存器分配的寄存器资源进行建模。表\ref{tab:dsp_register_class}给出了DSP架构中主要寄存器类的数量、位宽及功能特性，为后续寄存器组划分与寄存器组选择策略的设计提供硬件基础。表中列出的仅为DSP架构下部分不透明寄存器类及其功能描述，其中不透明寄存器类是指对编译器后端可见、并参与寄存器分配与调度的寄存器集合；而对开发人员透明的寄存器类（如中断返回地址寄存器、基址寄存器、偏移寄存器及取模寄存器等）由于其使用方式固定，不参与寄存器分配过程，故不在此列出。

\begin{table}[htbp]
	\centering
	\caption{DSP 架构主要寄存器类特性}
	\label{tab:dsp_register_class}
	
	\renewcommand{\arraystretch}{1.2}
	{\footnotesize
		\begin{tabularx}{\linewidth}{
				>{\raggedright\arraybackslash}m{2.5cm}
				>{\centering\arraybackslash}m{1.0cm}
				>{\centering\arraybackslash}m{1.4cm}
				>{\centering\arraybackslash}X
			}
			\toprule
			寄存器类 & 数量 & 宽度 / bit & 功能描述 \\
			\midrule
			通用寄存器（GR） & 32 & 32 & 使用频率最高的寄存器，用于存放标量指令中的运算数据及地址信息，支撑整型运算与内存访问等基础操作 \\
			
			矢量寄存器（VR） & $4 \times 16$ & 640 & 用于存放矢量运算数据，采用四路并行设计，支持 SIMD 模式下多数据元素的并行加载、存储与计算 \\
			
			控制寄存器（CR） & 1 & 32 & 用于保存处理器状态信息，包括进位标志、溢出标志以及比较指令的结果标志等，参与指令执行控制与条件判断 \\
			\bottomrule
		\end{tabularx}
	}
\end{table}

在DSP架构编译器后端的RegisterInfo类中，通用寄存器被划归至CPURegs寄存器类，矢量寄存器被划归至CPUVecRegs寄存器类，控制寄存器被划归至CCR寄存器类。上述寄存器类的划分构成了寄存器组定义的基础，基于该分类体系完成了DSP架构寄存器组的定义如下：
	
\lstset{language=c++}
\begin{lstlisting}
def GPRBRegBank : RegisterBank<"GPRB", [GPR32, GPR64]>;
def VPRBRegBank : RegisterBank<"GPRB", [VPR4Out, VPR8Out, VPR16Out]>;
def CRBRegBank  : RegisterBank<"CRB",  [CCR]>;
\end{lstlisting}

2.映射结构的定义

图\ref{fig:mapping}直观展示了GlobalISel框架中寄存器组选择阶段采用的分层映射结构，以及该结构在不同类型指令上的具体应用方式。该映射体系自底向上由PartialMapping、ValueMapping和InstructionMapping三个层次逐级构成，用于描述指令操作数到寄存器组的映射关系及其代价评估过程。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/mapping.png}
	\caption{寄存器组分层映射结构图}
	\label{fig:mapping}
\end{figure}

在最底层，PartialMapping用于描述操作数中某一连续比特区间到特定寄存器组的映射关系，支持大整数拆分、向量拆分以及非对齐布局等情况。例如，对于64位整型加法指令G\_ADD，其操作数可通过一个PartialMapping将$0\sim64$位整体映射至通用寄存器组GPRB；而对于32位整型比较指令G\_ICMP，其操作数仅需将$0\sim32$位映射至GPRB。对于控制类操作数，则通过PartialMapping将对应比特区间映射至控制寄存器组CRB；在矢量指令VADD场景下，宽达2048位的矢量操作数整体映射至矢量寄存器组VPRB。

\par

ValueMapping由一个或多个PartialMapping组合而成，用于描述单个操作数到寄存器组的完整映射方案。图中展示了同一类通用操作数可能存在多种ValueMapping方案的情况，不同方案对应不同的映射代价，用于反映寄存器使用效率或潜在的跨寄存器组数据复制开销。如图中的64位G\_ADD，其操作数既可以用一个GPR64来映射，又可以用两个GPR32来映射。

\par

在最上层，InstructionMapping对一条指令的所有操作数映射进行统一建模，其不仅包含每个操作数对应的ValueMapping，还关联了该指令整体映射方案的代价值。以图中所示为例，G\_ADD、G\_ICMP以及VADD等指令均可生成各自的InstructionMapping，其总代价由各操作数映射代价综合决定。寄存器组选择阶段将基于这些代价信息，在满足指令硬性约束的前提下选择最优映射方案。

\par

在具体实现中，主要有两种寄存器组分配策略。其中，Fast策略仅为指令选择默认可用的寄存器组组合，不对备选方案进行枚举与评估，因此实现简单、运行开销低，适用于对编译速度敏感的场景；而Greedy策略则在默认映射方案的基础上，进一步枚举目标架构允许的所有合法寄存器组组合，逐一计算其映射代价，并最终选择代价最低的方案。该策略能够在更大搜索空间内优化寄存器组分配，减少跨寄存器组的数据复制开销，但相应地增加了寄存器组选择阶段的计算成本。

\par

在LLVM的RegisterBankInfo实现中，PartialMapping、ValueMapping等结构通常以静态表的方式定义，用于描述不同位宽、不同操作数类型在目标架构下的寄存器组映射规则。通过这种表驱动的实现方式，寄存器组选择阶段能够在不依赖具体指令实例的前提下，高效查询操作数的映射方案及其对应代价，从而支撑后续InstructionMapping的构建与选择。下面代码片段给出了DSP目标架构中PartialMapping与ValueMapping的典型定义方式，其中PartialMapping用于描述操作数比特区间到寄存器组的基础映射，而ValueMapping则通过组合一个或多个PartialMapping，形成对单个操作数的完整寄存器组映射描述。

\lstset{language=c++}
\begin{lstlisting}
PartialMapping PartMappings[] = {
	{0, 32, GPRBRegBank},
	{0, 64, GPRBRegBank},
	{0, 32, CRBRegBank},
	...... };

ValueMapping ValueMappings[] = {
	{nullptr, 0},
	{&PartMappings[PMI_GPRB32], 1},
	{&PartMappings[PMI_GPRB32], 1},
	{&PartMappings[PMI_GPRB32], 1},
	{&PartMappings[PMI_GPRB64], 1},
	{&PartMappings[PMI_GPRB64], 1},
	{&PartMappings[PMI_GPRB64], 1},
	...... };
\end{lstlisting}

通过上述分层映射结构，寄存器组选择阶段实现了从比特级映射到指令级决策的逐层抽象，既避免了过早绑定具体物理寄存器，又能够在全指令粒度上评估不同寄存器组分配方案的代价，为后续指令选择与寄存器分配阶段提供了清晰的寄存器资源使用边界。


3.映射逻辑的实现

寄存器组选择的核心逻辑通过重载RegisterBankInfo类中的相关接口函数实现，其中最关键的是getInstrMapping与getInstrAlternativeMapping两个函数。前者用于为指令生成默认的寄存器组映射方案，后者则用于在必要时提供备选映射方案，以支持更灵活的寄存器组分配策略。

\par

getInstrMapping的实现流程如算法\ref{alg:mapping-core}所示。，其实现采用以规则驱动为核心的寄存器组映射构建流程。该流程首先以指令操作码为入口，对可直接由 TableGen 规则覆盖的场景进行快速判定。对于非通用指令及PHI指令，优先尝试使用TableGen自动生成的映射结果；一旦匹配成功，即可直接返回对应的InstructionMapping，从而避免后续不必要的分析与代价评估。

\par

当TableGen映射不可用时，算法进入基于操作数语义的通用映射阶段。此阶段以操作数为粒度，遍历指令中的所有寄存器操作数，并依据其LLT进行映射决策。在完成默认映射后，算法进一步结合指令语义对映射结果进行修正。对于使用条件值的指令，其条件操作数需显式映射至控制寄存器组，以保证条件语义与目标架构控制寄存器模型的一致性。最终，算法基于上述映射规则构建并返回完整的InstructionMapping。

\begin{algorithm}[htbp]
	\SetAlgoLined
	\linespread{1}\selectfont
	
	\KwIn{MI: Machine Instruction}
	\KwOut{InstructionMapping}
	\caption{Core Logic of getInstrMapping}
	\label{alg:mapping-core}
	
	Opc \gets opcode of MI\;
	
	\If{MI is non-generic or Opc is G\_PHI}{
		Mapping \gets getInstrMappingImpl(MI)\;
		\If{Mapping is valid}{
			\Return Mapping\;
		}
	}
	
	Initialize operand mapping array OpdsMapping\;
	
	\BlankLine
	\ForEach{operand op in MI}{
		\If{op is a register and op.reg is valid}{
			Obtain the low-level type Ty of op.reg\;
			\If{Ty is invalid or bit width of Ty $\le$ 32}{
				Assign op to a 32-bit GPR container\;
			}
			\Else{
				Assign op to a 64-bit GPR container\;
			}
		}
	}
	
	\BlankLine
	\If{Opc consumes a condition value}{
		Override the mapping of the condition operand to the control register bank (CRB)\;
	}
	
	\If{Opc produces a comparison result}{
		Force the result operand to use a 32-bit GPR container\;
	}
	
	\BlankLine
	Construct and return the final InstructionMapping from OpdsMapping\;
\end{algorithm}


%*********************************************************************
% 2.5 机器指令选择
%*********************************************************************
\section{机器指令选择}
机器指令选择是GlobalISel框架的第二阶段核心任务，承接第一阶段（GMIR生成、指令合法化、寄存器类型选择）的处理结果，其核心目标是将经过合法化的、附着目标架构信息的通用机器中间表示GMIR，完整转换为目标架构专属的机器中间表示MIR，为后续基于MIR的寄存器分配、指令调度、窥孔优化等后端流程提供合法输入，是衔接通用中间表示与架构专属表示的关键枢纽。

\par

机器指令选择以单个函数为处理粒度，基于树覆盖的指令选择算法，通过将GMIR指令序列构建为AST，再通过树模式匹配映射为目标架构指令序列，确保语义等价性与架构兼容性。目前框架实现了两种树覆盖的方式：一种是基于表驱动的自动状态机进行的自动覆盖方式；另一种是基于固定模式的手动覆盖方式。这两种覆盖方式在每次覆盖的时候都只会产生一种成功匹配的树模式，因此可以直接生成对应的MIR指令序列\cite{PengLLVM2024}。值得注意的是，GlobalISel的机器指令选择与传统基于DAG的指令选择存在显著设计差异，后者因引入DAG中间表示，需在选择阶段额外执行拓扑排序流程，导致实现复杂度与设计难度显著提升，而GlobalISel通过直接基于GMIR的树覆盖匹配规避了这一环节，简化了整体设计逻辑。

\par

机器指令选择采用PROT+自底向上处理的执行逻辑，确保指令依赖关系的正确性与处理效率，具体流程如下：首先以单个函数为处理单元，采用RPOT算法从函数底部开始依次扫描所有基本块，该遍历顺序可保障父基本块的指令处理滞后于子基本块，避免因分支依赖导致的未定义指令引用问题；进入单个基本块后，按自底向上的顺序逐行处理每条GMIR指令，处理前先判断当前指令是否已生成对应的MIR指令，若已生成则直接跳过以避免重复处理，若未生成则以该指令为根节点触发自动匹配模块与手动匹配模块的协同匹配流程；匹配成功后由指令生成模块输出对应的MIR指令序列，若匹配失败则直接触发编译报错；最后以基本块为单位迭代执行上述流程，直至整个函数的所有GMIR指令均成功转换为MIR指令或触发报错，完成该函数的机器指令选择任务。


% 2.5.1 匹配状态机
\subsection{匹配状态机}
在LLVM的指令选择体系中，匹配状态机是支撑基于表驱动的树覆盖指令选择的核心底层组件，其本质是一种由TableGen工具自动生成的FSM（Finite State Machine，有限状态机），其核心作用是将GMIR指令构成的AST与目标架构的指令模式进行自动化匹配，从而确定可映射为MIR的合法目标指令模式。

\par

在生成阶段，通过在td文件中以树模式的形式描述目标架构指令的结构特征。TableGen工具对所有指令树模式进行解析，提取其中的关键信息，包括操作码、操作数类型、寄存器组约束以及数据位宽等，并将这些特征系统化地编码为状态机的状态节点与转移条件。其中，状态节点对应指令树在不同层级上的特征匹配状态，而转移条件则描述从当前特征匹配到下一层特征的合法规则。最终，TableGen将所有状态节点与转移关系整合为完整的状态机代码，覆盖从初始状态、匹配中状态到成功匹配状态或失败状态的完整流程，且每一个成功匹配状态均唯一对应一条目标架构指令模式。

\par

在机器指令选择阶段，匹配状态机针对单条GMIR指令的执行流程可概括为以下几个步骤：

\begin{enumerate}
	\item
	指令树构建：以当前待处理的GMIR指令为根节点，递归遍历其操作数、子指令，构建完整的抽象语法树。
	
	\item
	状态机初始化：将状态机置为初始状态，从指令树的叶子节点开始向上遍历。
	
	\item 
	状态转移匹配：在遍历过程中，根据当前AST节点的特征触发状态机的转移并进入对应状态；若在某一节点处不存在满足条件的转移路径，则判定该子树匹配失败，状态机回退至最近的分支点并尝试其他可行路径；当遍历至根节点且状态机进入成功匹配状态时，即输出对应的目标架构指令树模式。
	
\end{enumerate}

为保证匹配结果的确定性，LLVM中的指令匹配状态机被设计为DFA（Deterministic Finite Automaton，确定性有限状态机）。在该设计下，同一指令树在匹配过程中仅会触发唯一的一条状态转移路径，并最终生成唯一的成功匹配结果，从机制上避免了多模式冲突问题。

\par

匹配状态机在指令选择阶段的主要优势体现在自动化与可扩展性。开发时无需为每条目标指令手工编写匹配逻辑，只需在td文件中定义相应的指令树模式，即可由TableGen自动生成匹配状态机，从而降低目标架构适配所需的代码量。当目标架构新增指令时，也仅需补充对应的树模式并重新生成状态机，无需修改编译器核心代码，保证了指令选择框架的稳定性与可维护性。此外，匹配状态机采用确定性遍历机制，在匹配过程中避免了对所有指令模式的穷举搜索。相较于手动遍历或回溯式匹配方法，该机制能够显著提升指令匹配效率。


% 2.5.2 机器指令选择方法
\subsection{机器指令选择方法}
从功能划分的角度来看，机器指令选择可划分为三个模块：自动匹配模块、手动匹配模块以及指令生成模块。三者共同完成从GMIR到MIR的语义映射过程。

\par

1.自动匹配模块

自动匹配模块负责构建基于表驱动的自动状态机，通过状态转移的方式自动完成GMIR指令与目标架构指令模式之间的匹配，其优势在于无需人工干预即可适配大部分通用指令的匹配需求，提升编译器对指令集扩展的自适应能力。这种设计不仅显著减少了手写匹配代码的工作量，也提升了编译器在面对指令集扩展或新增指令时的可维护性与可扩展性。

\par

自动匹配模块的工作流程可进一步划分为两个阶段：
第一阶段发生在编译器构建期，由TableGen工具解析目标架构指令的树模式描述，并将其编码为确定性有限状态机；第二阶段发生在编译期，指令选择器利用已生成的状态机，对单条GMIR指令构建的抽象语法树进行自底向上的遍历，通过状态转移自动判定其可匹配的目标指令模式。

\par

为兼容SelectionDAGISel，GlobalISel对通用算术与逻辑指令直接复用既有指令模式，而对依赖SDNode的架构专属信息则重新建模，并通过GINodeEquiv显式建立GMIR操作码与ISD操作码的等价关系，实现指令模式的复用。以下示例展示了加法指令的映射。

\lstset{language=c++}
\begin{lstlisting}
Class GINodeEquiv<Instruction i, SDNode node> {
	Instruction I = i;
	SDNode Node = node;
}

def : GINodeEquiv<G_ADD, add>;
\end{lstlisting}

2.手动匹配模块

尽管自动匹配模块能够覆盖大多数通用指令的选择需求，但在实际工程中仍存在部分目标架构特有的复杂指令，其语义或操作数约束难以通过TableGen的树模式进行完整描述。针对这类场景，需要通过自定义C++代码实现精细化的指令匹配逻辑。

\par

手动匹配模块通常以内置固定树模式或显式条件判断的形式存在，通过逐条检查GMIR指令的操作码、操作数类型及寄存器约束，判定其是否符合特定架构专属指令的语义特征。一旦匹配成功，即直接生成对应的目标指令。该模块作为自动匹配的补充机制，主要用于处理高度架构相关、对性能或硬件语义要求严格的指令场景，弥补纯表驱动匹配在表达能力上的不足。

3.指令生成模块

指令生成模块位于机器指令选择流程的末端，其输入为自动匹配或手动匹配阶段选定的指令树模式。该模块依据模式与目标架构指令之间的映射关系，构造语义等价的MIR指令序列，并完成必要的操作数绑定与属性设置。通过该模块，GMIR中的通用指令被最终转换为与目标架构紧密绑定、可直接参与后续寄存器分配与指令调度的机器指令表示。


% 2.5.2 机器指令选择实现
\subsection{机器指令选择实现}

机器指令选择阶段以单条GMIR指令为处理粒度，其整体流程可概括为预处理、特殊指令处理、合法性校验、自动匹配以及手动匹配五个阶段，如算法\ref{alg:isel-core}所示。

1.预处理

为适配DSP目标架构的指令语义，指令选择前需对部分通用指令执行前置Lowering，将其规范化为更贴近硬件的等价形式。典型场景是指针相关操作：由于DSP架构缺少独立的指针运算指令，指针通常以整型寄存器保存并参与运算，因此需要将带指针语义的通用指令转换为等价的整型语义指令，并同步修正结果寄存器的LLT，保证后续匹配与约束的一致性。

2.特殊指令处理

对于语义或结构特殊、难以通过树模式描述的指令，需要在自动匹配之前进行单独处理，主要包括以下几类。

\begin{itemize}
	\item
	PHI指令用于描述控制流汇合处的SSA值合并，属于编译器内部语义，不对应具体硬件指令，其处理重点在于保证定义寄存器与各输入操作数满足一致的寄存器约束，以确保后续寄存器分配的合法性。

	\item
	COPY指令仅承担数据搬运语义，不包含可匹配的运算结构，且可能涉及虚拟寄存器与物理寄存器之间或跨寄存器资源的数据复制，通常无法通过通用树模式完成映射，因此需要采用专门的选择逻辑。

	\item 
	此外，由于DSP架构的ISA限制，对于依赖控制寄存器Condition位的指令，如G\_BRCOND、G\_ICMP、G\_FCMP以及G\_SELECT等，需在TableGen驱动的通用匹配流程之前进行提前处理。通过在指令选择阶段直接识别并生成符合目标架构条件码语义的指令序列，可以避免条件值经由普通数据路径再映射至控制寄存器所带来的冗余指令与数据搬移开销。
	
\end{itemize}

3.合法性校验
在进入模式匹配前，对指令结构进行必要的合法性检查。例如，通用指令不应携带未显式声明的隐式操作数；若指令形态异常，直接返回失败以避免产生不一致的选择结果，并便于定位后端实现问题。

4.自动匹配
对通过前述阶段筛选的通用指令，调用selectImpl执行基于TableGen的树覆盖匹配。该路径覆盖面广、维护成本低，能够将绝大多数通用算术、逻辑、访存等指令自动映射为目标指令模式，是指令选择的主要实现方式。

5.手动匹配
当指令无法被自动匹配覆盖时采用手动匹配。手动匹配通常以专用选择函数的形式存在，对操作数、立即数约束及目标指令序列进行精确构造。例如，针对寄存器内符号扩展的 G\_SEXT\_INREG，可通过检查扩展位宽并构造等价的目标指令序列完成选择，同时对新生成指令施加寄存器约束，保证与后续流程兼容。

\par

手动匹配在处理指令集差异时尤为关键。以UMULH（无符号高半乘法）为例：对于原生支持该指令的芯片型号，可以直接通过TableGen的Pattern将GMIR操作映射为硬件指令；而对于不支持UMULH的型号，则需要在手动路径中将其展开为等价指令序列。

\par

这种设计使得条件值的生成、传递与使用能够保持在最小且明确的指令路径上，不仅简化了指令选择过程，降低了指令序列中冗余复制操作的数量，还减少了寄存器压力和执行延迟，对分支频繁、条件判断密集的程序尤为有利，有助于提升最终生成代码的整体执行效率。

\begin{algorithm}[htbp]
	\SetAlgoLined
	\linespread{1}\selectfont
	
	\KwIn{MI: Machine Instruction}
	\KwOut{Boolean: Instruction selection result}
	\caption{Core Logic of Instruction Selector}
	\label{alg:isel-core}
	Initialize context objects for MI (MBB, MF, MRI, MIB)\;
	Execute pre-selection lowering on MI\;
	
	\If{MI is a copy instruction}{
		\Return Process copy instruction selection for MI\;
	}
	Get opcode (Opc) of MI\;
	
	\If{Opc is G\_PHI}{
		Extract target register (DefReg) of PHI\;
		Derive target register class (DefRC) of DefReg\;
		\If{DefRC derivation fails}{
			\Return false\;
		}
		\For{each operand in PHI instruction}{
			\If{Operand cannot be constrained to DefRC}{
				\Return false\;
			}
		}
		Update PHI instruction descriptor\;
		\Return Constrain DefReg to DefRC\;
	}
	
	\If{MI has implicit operands not declared explicitly}{
		\Return false\;
	}
	
	\If{Opc is a condition-related generic instruction}{
		\Return Apply condition-specific selection\;
	}
	\If{table-driven selectImpl succeeds}{\Return true\;}
	
	\If{Opc is a special-type generic instruction}{
		\Return Apply special-type instruction selection\;
	}
	\Return false\;
\end{algorithm}


%*********************************************************************
% 2.6 本章小结
%*********************************************************************
\section{本章小结}
本章围绕GlobalISel在DSP架构上的实现，对全局指令选择框架的关键组成与实现路径进行了系统阐述。首先，对LLVM现有指令选择体系进行了对比分析，指出传统SelectionDAGISel在流程复杂度、维护成本与灵活性方面的局限，以及FastISel在代码质量与覆盖能力上的不足，从而引出GlobalISel以GMIR为核心载体、以函数为粒度的整体设计思路与流程拆分方式。

\par

随后，本章给出了GlobalISel第一阶段GMIR生成的实现要点，重点说明了通用翻译逻辑与目标架构相关逻辑的分层协作机制。针对DSP架构在ABI、寄存器宽度与数据类型支持方面的约束，本文通过定制ValueHandler，实现了参数传递、返回值处理及调用指令构建等关键环节，保证了LLVM IR到GMIR的语义下沉过程在DSP平台上的正确性与可扩展性。

\par

在合法化阶段，本章阐述了基于LegalizerInfo规则集的合法性判定机制，并结合DSP平台的类型集合与指令支持范围构建合法化规则；同时针对通用规则难以覆盖的复杂场景，给出了基于Custom的专用处理方式，以确保GMIR能够完全落入目标硬件能力边界，为后续流程提供稳定输入。

\par

在寄存器组选择阶段，本章阐述了Register Bank抽象在多寄存器文件架构中的工程意义，并结合DSP寄存器资源划分，给出了寄存器组与寄存器类的建模方式。进一步地，本文基于Mapping的三层映射结构，说明了寄存器组选择的映射构建与代价评估机制，并给出getInstrMapping及备选映射接口在DSP后端中的实现策略，为降低跨寄存器组数据搬移开销提供支撑。

\par

最后，在机器指令选择阶段，本章总结了GlobalISel基于树覆盖的选择方法，并给出了DSP指令选择器的核心流程：通过预处理与特殊指令处理保障输入形态一致性，在此基础上优先采用TableGen驱动的自动匹配完成通用指令选择，同时以手动匹配补充复杂指令或架构特化语义。至此，本章完成了从LLVM IR到DSP架构MIR的关键路径打通，为后续章节针对全局指令选择的优化策略设计与性能评估奠定了实现基础与实验前提。
