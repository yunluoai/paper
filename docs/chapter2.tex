\chapter{面向DSP的全局指令选择实现}
编译器后端指令选择阶段的工作是将LLVM IR（Intermediate Representation，中间表示）转换为目标架构MI（Machine Instruction，机器指令）。这一阶段所要解决的问题是在保持程序语义不变的基础上生成适用于目标架构的指令序列。这个过程对生成的目标代码质量、资源利用率以及编译器对各种复杂硬件架构的兼容性有很大影响，是连接前后端的重要纽带。

\par

随着处理器架构的不断发展以及LLVM编译器基础设施的不断成熟，指令选择的实现方式也在不断变化。出于不同应用场景及性能要求的考虑，LLVM演变出不同的指令选择实现方案，先后引入了快速指令选择、基于有向无环图的指令选择以及全局指令选择这3个指令选择实现技术路线。这3种指令选择方案在设计思路、适用性以及代码生成质量特点上各有侧重。

\par

LLVM编译器主要依赖基于有向无环图的指令选择方案来生成高质量代码，但其复杂的图变换流程与以基本块为限的优化范围，导致编译时间长、内存占用高，且难以维护。与此同时，面向调试的快速指令选择方案虽提升了编译速度，但其简化的匹配逻辑无法满足DSP应用对代码密度与指令级并行的严苛要求。这两种方案在适配指令集异构性强、硬件约束复杂的现代DSP处理器时，均显现出固有的局限性。

\par

为应对上述挑战，本章结合DSP的硬件与指令集特点，设计并实现了面向DSP的全局指令选择框架，旨在为DSP架构构建一个兼具编译效率、代码质量与架构适配灵活性的新型指令选择流程。GlobalISel采用一种更贴近机器指令的通用中间表示，并以函数为粒度进行全局性的指令选择与优化，这为充分挖掘DSP硬件特性、减少冗余指令和数据移动开销提供了新的可能。

\par

本章将系统阐述GlobalISel在DSP目标架构上的完整实现路径。首先，将对传统指令选择方案的原理与局限进行对比分析，以明晰技术演进脉络与选型依据。随后，将依据GlobalISel的核心流程，分阶段深入剖析其关键实现：GMIR生成阶段负责完成语义转换与初步架构适配；指令合法化阶段确保所有操作均落在硬件能力范围内；寄存器组选择阶段负责优化寄存器文件映射以降低数据搬移成本；机器指令选择阶段最终完成到目标指令的精确映射。


%*********************************************************************
% 2.1 全局指令选择框架概述
%*********************************************************************
\section{全局指令选择框架概述}


% 2.1.1 传统指令选择方案及其局限性
\subsection{传统指令选择方案及其局限性}
在LLVM的早期发展阶段，指令选择的目标是保证LLVM IR能够正确、稳定地映射为目标架构支持的机器指令，并在开启优化选项时能生成质量较高的代码。为此LLVM采用了基于DAG的指令选择方案。该方案是LLVM长期以来的主流指令选择方案，也是高优化等级下的默认指令选择方案。该方案支持复杂架构指令集，能够处理X86、ARM以及RISCV等各种架构复杂的指令选择需求。

\par

基于DAG的指令选择方案通过将基本块内的LLVM IR转换为SelectionDAG，对SelectionDAG进行指令合法化、节点合并以及指令匹配替换等操作，从而实现中间表示转成对应机器指令的映射过程。方案的整体处理流程如图\ref{fig:dag_flowchart}所示。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/dag_flowchart.png}
	\caption{SelectionDAGISel流程图}
	\label{fig:dag_flowchart}
\end{figure}

SelectionDAGISel的设计思路是将LLVM IR转换成DAG来表示指令间的数据流依赖关系，然后再通过模式匹配和树覆盖的方法来将DAG内的节点转换为目标架构的机器指令。SelectionDAGISel的执行过程分为三个阶段：第一阶段，框架将LLVM IR指令序列转为SelectionDAG。在DAG图中每个节点表示一种操作，边表示数据依赖，能直观地看到指令之间的数据流依赖关系，不再需要对指令进行线性的扫描；第二阶段，为了简化后续的匹配流程，框架对SelectionDAG进行标准化操作及优化；第三阶段，框架采用基于TableGen自动生成的模式匹配器，对优化后的SelectionDAG进行拓扑排序，通过自底向上遍历节点来匹配目标架构在.td文件中定义的DAG模式，之后将匹配成功的节点替换为对应的机器指令，最终生成目标架构的机器代码。图\ref{fig:dag_example}展示了一个简单自增运算函数在指令选择阶段生成、调度之前的部分SelectionDAG图。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{pics/dag_example.pdf}
	\caption{自增运算函数部分SelectionDAG图示例}
	\label{fig:dag_example}
\end{figure}

利用SelectionDAG结构，SelectionDAGISel可以实现对全局数据流进行详细分析，能够对指令进行比较复杂的优化、合成，并能提高生成代码的质量。此外，开发者仅需在描述文件中定义指令模式就可以自动生成匹配代码，大大降低新架构的适应开发成本。但是这种指令选择方案的设计比较复杂，这是因为SelectionDAG的构造、优化、拓扑排序等都需要比较复杂的逻辑，并且DAG与LLVM IR及机器指令之间的转换也需要额外的转化层，增加了设计的复杂度。

\par

而随着LLVM编译器生态的发展，LLVM因其模块化的特征、良好的跨平台兼容性等特点，在各种大型工业软件开发、复杂代码调试和维护等场景中得到了广泛应用。在这样的背景下，低优化等级下快速地编译代码成为了关键诉求。为了满足项目调试构建过程快速编译的这一需求，LLVM在原来的SelectionDAGISel框架之外引入了FastISel框架。FastISel是LLVM为平衡编译速度与代码质量设计的轻量级指令选择方案，FastISel的核心定位是优先考虑编译速度，同时兼顾基础指令选择需求，其主要用于O0优化等级下的代码生成。

\par

从设计原理来看，快速指令选择采用线性扫描+模式匹配的策略，以单个指令为处理单位，不构建复杂的中间表示结构。其核心流程为：遍历LLVM IR指令序列，对每条指令直接匹配目标架构的简单指令模式，匹配成功则直接生成机器指令，匹配失败则回退到基于DAG的指令选择。方案的整体流程如图\ref{fig:fast_flowchart}所示。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.7\textwidth]{pics/fast_flowchart.png}
	\caption{FastISel流程图}
	\label{fig:fast_flowchart}
\end{figure}

为了提高编译速度，快速指令选择采用手写C++代码的方式来实现匹配规则。这种方式能够有效地避免TableGen工具的解析、代码产生所带来的额外成本，也避免了指令间的依赖分析以及复杂的优化逻辑。使用快速指令选择的编译效率非常高，在调试模式下能大幅度减少编译的时间，但FastISel也有局限性。因为只有简单指令模式的匹配，无法匹配比较复杂的指令模式（如向量运算、指令融合等等），导致生成的代码质量较低。

\par

除此之外，FastISel缺乏全局视角，无法做跨指令的数据流和控制流优化，在性能敏感的场合无法满足性能要求。所以快速指令选择只能作为一种调试的默认模式，仅适合用来调试和快速编译，在对性能敏感的优化阶段仍然需要更强的指令选择机制。

\par

近些年来，编译器的应用领域不断拓展，这些传统指令选择方案无论是在编译速度，还是在架构独立性上都难以适应新的应用需求。具体而言，SelectionDAGISel的复杂中间表示及其相应优化机制增加了编译流程的复杂性和维护的负担，以及由于SelectionDAGISel的局部作用域的特性，SelectionDAGISel在处理基本块间复杂优化等复杂情况下存在着明显的不足。这些问题推动了新一代指令选择机制的产生和发展。


% 2.1.2 全局指令选择原理及框架设计
\subsection{全局指令选择原理及框架设计}
全局指令选择是LLVM为突破基于DAG的指令选择框架的局限性而推出的全新指令选择方案。全局指令选择的核心目标在于平衡编译速度、代码质量以及架构适配的灵活性，并且通过统一的流程实现从LLVM IR到机器指令的转换。

\par

从设计理念来看，全局指令选择摒弃了基于DAG的专用中间表示，转而使用GMIR（Generic Machine Intermediate Representation，通用机器中间表示）作为其核心载体。GMIR本质上是对LLVM IR的轻量级扩展，在保留了LLVM IR的语义特征的同时引入了目标架构的基础信息，这使得在指令选择的过程无需在多种中间表示间进行频繁转换，从而简化了整体流程。

\par

GlobalISel的核心优势是全局性和灵活性。全局性体现在GlobalISel是以函数为粒度的，结合全局的控制流和数据流，用全局视角进行指令选择，所以GlobalISel可以对一个基本块内部的指令序列进行优化；而灵活性是指GlobalISel具备手动和自动两种模式进行匹配，在自动模式下除了可以根据TableGen进行匹配外，还可以重用基于DAG的指令选择的那部分对指令集的描述信息，这样前期的设计工作量会大大降低。

\par

全局指令选择的执行流程分为两个核心阶段：第一阶段为GMIR预处理，包括将LLVM IR转换为原始GMIR、指令合法化、寄存器类型选择，最终生成附着目标架构信息的合法GMIR；第二阶段为机器指令选择，以函数为粒度，采用基于树覆盖的指令选择算法，通过自动匹配模块和手动匹配模块，将GMIR指令树映射为MIR（Machine Intermediate Representation，目标架构的机器中间表示），同时将通用虚拟寄存器限制到具体的寄存器类中，并传递COPY指令至后续的寄存器分配阶段。

\par

全局指令选择将两个阶段涉及的每个功能都拆分成独立的Pass，这样既能使整体的架构更加清晰，也能够方便利用LLVM Pass的相关基础设施进行代码维护和问题分析定位。LLVM实现中将全局指令选择所必需的基本功能划分为4个Pass，其中第一阶段包含3个Pass，而第二阶段为1个Pass。还有窥孔类的优化也会以独立Pass进行实现，并可以放置在4个基础Pass之间的任意位置，不同的架构可以根据需要配置一到多个这种优化Pass。该流程如图\ref{fig:global_flowchart}所示。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/global_flowchart.png}
	\caption{GlobalISel流程图}
	\label{fig:global_flowchart}
\end{figure}

相比于前两种指令选择方案，GlobalISel实现了在编译效率、代码质量和架构适配性之间的多维度平衡。从编译速度的角度来看，GlobalISel摒弃了SelectionDAG中复杂的处理流程，编译效率接近快速指令选择；从代码质量的角度来看，凭借其全局视角和复杂模式的匹配能力，GlobalISel能够生成与基于DAG的指令选择相当的高质量代码；从架构适配性的角度来看，GlobalISel的模块化设计使其能更方便地扩展和维护，由于GlobalISel采用通用的GMIR表示和灵活的模式匹配方式，使其更容易地适配新架构，尤其是包含特殊寄存器组或独特指令集的架构。


%*********************************************************************
% 2.2 GMIR生成
%*********************************************************************
\section{GMIR生成}
GMIR的生成是GlobalISel第一阶段的第一个Pass，也称为IRTranslator。IRTranslator阶段的任务是完成LLVM IR到GMIR的语义下沉与架构适配，核心是要完成寄存器处理、栈管理以及调用约定处理等操作。IRTranslator的实现以目标平台的ABI（Application Binary Interface，应用二进制接口）约定、指令集特性及数据类型支持为核心依据，通过模块化的调用处理机制，确保函数调用、参数传递、返回值处理的正确性与高效性。


% 2.2.1 通用机器表示
\subsection{通用机器表示}
GMIR是GlobalISel的中间层表示，在LLVM IR与目标机器强相关的MIR之间起到承上启下的作用。GMIR的设计目标之一就是在保留通用机器语义的同时延迟引入具体架构细节，这样的好处是可以为跨平台指令选择、合法化以及后继的优化提供统一而稳定的基础。通过这一设计，GlobalISel能够在更大作用域内进行分析与决策，避免过早绑定目标架构而减少优化空间。GMIR由四个要素组成：

\begin{enumerate}
	\item
	通用虚拟寄存器（Generic Virtual Register）：不绑定具体物理寄存器，由MachineRegisterInfo统一管理生命周期，是GMIR中数据传递的核心载体，如函数参数、运算结果均存储于虚拟寄存器。
	
	\item
	通用指令集（Generic Instructions）：覆盖算术运算、逻辑运算、内存访问、分支跳转、函数调用与返回等基础操作，指令格式标准化，避免架构专属指令的碎片化。
	
	\item 
	LLT（Low-Level Type，低级别类型）：基于位宽和类型类别定义（如标量、指针、向量），摒弃了LLVM IR的高级类型（如结构体、类），更贴近硬件数据处理逻辑。
	
	\item 
	架构约束元数据：通过MachineMemOperand（内存访问属性）、RegMask（寄存器掩码）、CCValAssign（调用约定分配信息）等属性来系统化地表示目标架构的各种约束。
	
\end{enumerate}

在GlobalISel整体流程内，GMIR存在于指令选择前后的多个关键阶段。IRTranslator以函数为单位去遍历LLVM IR，把它直接映射成GMIR的通用指令和虚拟寄存器表示。在这一阶段，编译器可结合目标架构展开必要的特化处理，比如说DSP架构会对64位浮点运算进行拆分，而后进入到合法化阶段，框架要对GMIR里目标架构不直接支持的指令及参数类型修正，保证其完全在硬件能力范围之内。在寄存器组选择阶段，框架把通用虚拟寄存器映射到目标架构定义的寄存器组当中，为后续的物理寄存器分配奠定基础。在指令选择阶段，框架会把GMIR的通用指令替换成目标架构的机器指令，最终生成与目标硬件紧密绑定的MIR表示。为进一步明确GMIR在LLVM编译流程中的抽象层级及其过渡性定位，表\ref{tab:ir_gmir_mir}对LLVM IR、GMIR与MIR在抽象层级、核心元素及架构相关性等方面进行了对比。

\begin{table}[htbp]
	\centering
	\caption{LLVM 不同中间表示层次对比}
	\label{tab:ir_gmir_mir}
	
	\renewcommand{\arraystretch}{1.2}
	{\footnotesize
		\begin{tabularx}{\linewidth}{
				>{\raggedright\arraybackslash}m{1.2cm}
				>{\centering\arraybackslash}X
				>{\centering\arraybackslash}X
				>{\centering\arraybackslash}X
				>{\centering\arraybackslash}X
			}
			\toprule
			类型 & 抽象层级 & 核心元素 & 架构相关性 & 核心作用 \\
			\midrule
			IR &
			高级语言无关抽象（函数、模块级） &
			函数、基本块、Value、LLVM IR 指令 &
			完全无关 &
			跨平台程序分析与中端优化 \\
			
			GMIR &
			通用机器语义抽象（指令、寄存器级） &
			通用虚拟寄存器、通用指令、LLT 类型 &
			部分相关 &
			衔接 LLVM IR 与架构相关 MIR，统一指令选择流程 \\
			
			MIR &
			目标架构专属抽象（硬件指令、物理寄存器级） &
			物理寄存器、目标架构指令、硬件约束 &
			完全相关（绑定具体硬件） &
			目标架构指令调度与寄存器分配 \\
			\bottomrule
		\end{tabularx}
	}
\end{table}

与SelectionDAGISel中LLVM IR到SelectionDAG的映射流程相比，GlobalISel的LLVM IR到GMIR的映射过程更加简单，语义更加完整，优化机会也更多。这个过程省掉了SelectionDAG流程中LLVM IR、SelectionDAG以及MachineDAG多次转换过程所带来的繁琐和开销，编译过程非常简单。同时，GMIR以函数粒度生成，能够保留LLVM IR中不同基本块之间的控制流和数据相关依赖信息的完整性，为函数级优化创造机会。另外，通用虚拟寄存器会跨基本块存在，LLT又对异构类型系统比较友好，这使得GMIR在更大范围内起作用，为跨基本块的指令合并、全局寄存器分配等任务提供支撑。


% 2.2.2 GMIR生成方法
\subsection{GMIR生成方法}
GMIR的指令分为两类：架构无关指令和架构相关指令，这样设计的好处在于既保留了通用优化的灵活性，又能通过架构特化逻辑适配不同硬件的底层约束。其中，架构无关指令包括算术指令、逻辑指令等，因为这类指令只表达通用机器的语义，不依赖于特定的硬件，故可以用GlobalISel统一生成；而架构相关指令主要是针对于硬件约束较强的指令操作，如函数调用、形式参数处理等操作。架构相关指令所依赖的ABI调用约定（即相应的寄存器约定、栈帧约定、参数传递约定等）是特定于目标机器的，必须有针对性地实现各种指令。

\par

IRTranslator是LLVM IR到GMIR的翻译器，负责对所有指令翻译过程进行协调和调度。在翻译的执行过程中，IRTranslator以函数为单位对LLVM IR中的指令进行逐条遍历，将这些指令转换成对应的通用机器指令表示，最终完成从高级中间表示到通用机器语义的译码转换，为后续阶段提供标准化的输入。

\par

CallLowering是IRTranslator的核心，包括了参数传递、返回值处理等调用约定的细节处理。IRTranslator在处理函数的入口、调用指令以及返回指令时，通过统一的接口调用目标后端的CallLowering来处理函数的常规翻译，从而实现通用翻译框架与目标架构定制的业务解耦。

\par

基于这种设计，GlobalISel能够在保持IRTranslator通用性的同时，还能实现对不同目标架构ABI差异的良好适配，从而实现通用指令翻译逻辑与目标架构定制逻辑之间的有效解耦。IRTranslator与CallLowering之间的关系及协作方式如图\ref{fig:irtranslator_call}所示。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.5\textwidth]{pics/irtranslator_call.png}
	\caption{IRTranslator调用降级流程及组件交互示意图}
	\label{fig:irtranslator_call}
\end{figure}

以函数调用约定处理为例，在函数调用的过程中需要将LLVM IR中抽象的函数调用、参数传递语义，转换为符合目标架构规范的GMIR。由于不同架构的寄存器布局、栈对齐要求、参数存储优先级（寄存器优先或栈优先）存在显著差异，因此需要由各目标架构单独实现专属的CallLowering模块，模块通过解析自身的ABI约定来完成LLVM IR到GMIR的精准映射，从而确保后续指令选择与硬件执行的兼容性。

\par

GMIR生成的执行过程是以函数为粒度进行的，与SelectionDAGISel是以基本块为粒度不同，由于函数可以分为包含形参信息的函数头与函数体，函数体又有基本块等表示，所以按处理的函数信息不同，将执行过程分为4个主要的阶段，如图\ref{fig:gmir_gen_flowchart}所示。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{pics/gmir_gen_flowchart.png}
	\caption{GMIR生成流程图}
	\label{fig:gmir_gen_flowchart}
\end{figure}

\begin{enumerate}
	\item
	创建基本块：这个阶段会遍历函数的LLVM IR基本块，依次为每个基本块创建对应的GMIR的基本块，并且会保留相关的控制流信息，形成初始的控制流图。还会为每个函数添加一个额外的基本块（EntryBB），作为函数入口。
	
	\item
	处理形参：根据目标架构的调用约定规则处理函数的入参，为每个入参生成一条从传参寄存器复制到虚拟寄存器的GMIR复制指令，或者为入参生成一条从栈上加载到虚拟寄存器的GMIR加载指令，并将生成的指令放入EntryBB中。
	
	\item 
	转换函数体指令：按RPOT（Reverse Post-Order Traversal，逆后序遍历）的方式遍历函数的控制流图，对于每个基本块，以自顶向下的顺序将基本块里的每条指令转换成一组GMIR指令。
	
	\item 
	更新控制流图：在第3阶段的指令转换过程中，有些原本不是跳转的指令会被翻译成跳转指令（例如，跳转指令的条件码是由多条连续的逻辑运算指令生成的，此时就有可能会拆分逻辑运算生成多个跳转指令），导致原有基本块被拆分出多个新基本块，破坏原有的控制流。因此在基本块指令转换好后，需要维护好这些新基本块与原有基本块的控制流边，形成新的控制流图。此外，转换过程还可能会将EntryBB和函数体中的第一个基本块合并，此时控制流信息也要跟着更新。
	
\end{enumerate}


% 2.2.3 GMIR生成实现
\subsection{GMIR生成实现}
根据2.2.2节设计可知，GMIR的指令生成逻辑分为架构无关和架构相关两类。算术运算、逻辑运算等架构无关指令的处理由框架统一实现。与DSP结构强绑定的函数调用、函数参数、结果值等架构相关指令的处理需要根据DSP的ABI、寄存器布局以及数据传输等特性来对CallLowering进行定制化开发。对于DSP结构来说，以上这些场景之间都会在寄存器宽度、类型支持、端序等方面有较大差异，因此也是IRTranslator实现的重点和难点。

\par

为适配DSP的特性，本文基于ValueHandler接口实现了DSPIncomingValueHandler和DSPOutgoingValueHandler两个辅助类，这两个辅助类分别负责函数入参数出参数的传递、函数返回值的返回，类的结构如图 \ref{fig:valuehandler}。这一设计将参数与函数返回值的相关处理从IRTranslator主流程中分离出来，可以让调用相关的架构特化代码能够集中被管理，有效地提高了可维护性和可扩展性。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.7\textwidth]{pics/valuehandler.png}
	\caption{DSPValueHandler核心函数}
	\label{fig:valuehandler}
\end{figure}

\begin{enumerate}
	\item
	getStackAddress用于生成DSP架构下栈帧空间的目标地址虚拟寄存器，根据上下文选择基于帧索引还是直接操作栈指针，为出参的栈上存储提供地址支持。
	
	\item
	assignValueToReg用于将目标值分配至物理寄存器，核心完成COPY指令构建，并按需标记虚拟寄存器的状态属性。
	
	\item 
	assignValueToAddress用于完成栈上数据的加载和存储，将其加载或存储在合适的位置并在需要时进行扩展。
	
	\item 
	assignCustomValue是针对DSP架构的定制化实现，采用数据的合并、拆分算法解决非法类型跨函数传入的情况。例如，函数根据DSP的端序特性调整高低位数据的存储顺序，保证了跨函数的属性一致性。除此之外，函数会利用G\_COPY指令将拆分的数据寻址映射到目标物理寄存器上。
	
\end{enumerate}

在具体的实现中，IRTranslator需要分别完成函数调用、形式参数以及返回值的降级处理等操作。其中，以lowerCall为例，其主要流程可概括为以下几个阶段：

\begin{enumerate}
	\item
	调用合法性校验：约束调用约定（如DSP仅支持C语言调用约定），确保跨函数调用的二进制兼容性；校验入参和返回值类型是否为架构支持的类型，提前拦截非法调用以避免后续流程异常。
	
	\item
	栈帧预处理与调用指令构建：lowerCall会先生成栈帧调整的起始指令，为调用过程预留所需的栈空间；随后根据被调用者的类型动态选择合适的调用指令，并将被调用者标识附加到调用指令中，从而为后续指令选择阶段提供明确的目标地址信息。
	
	\item 
	出参传递与栈空间校准：lowerCall对参数按DSP数据类型规则进行拆分，生成适配DSP结构的ArgInfo列表，再结合DSPCCState和参数调用规则ABI，解析参数的寄存器/栈分配规则，由DSPOutgoingValueAssigner给出分配值的具体计算和参数传递。最后获取DSP结构栈对齐的要求，将栈空间的大小按对齐要求校准，使栈访问符合硬件约束。
	
	
	\item 
	调用指令提交与间接调用约束：lowerCall将构建完成的调用指令（CALL/CALLR）插入当前基本块，若为CALLR指令，通过constrainAllUses结合DSP的RegisterBank信息及目标指令信息，约束指令操作数的合法性，避免跨银行访问或非法寄存器使用。
	
	\item 
	返回值处理与栈帧恢复：若返回值不为空，lowerCall则利用DSPIncomingValueAssigner解析出返回值分配策略，将物理返回值寄存器的值映射到通用虚拟寄存器，将栈指针恢复并释放调用过程占用的栈空间，从而完成整个调用流程。	
	
\end{enumerate}

上述IRTranslator的实现在DSP架构下实现了完整的函数调用、参数传递和返回等机制，解决了通用CallLowering逻辑在寄存器宽度和非法类型处理上的不足的问题，保证了语义正确性，也为后续指令合法化和指令选择阶段提供了清晰明确的中间表示基础。


%*********************************************************************
% 2.3 指令合法化
%*********************************************************************
\section{指令合法化}
在IRTranslator完成转换后，函数的表示方式由LLVM IR转变成了GMIR。这一转换并非简单的指令映射，而是伴随通用机器语义适配的深度处理。为了衔接后续环节，IRTranslator会在转换过程中嵌入部分目标架构的如寄存器组初步约束、调用约定相关标记等基础信息。但从设计本质来看，GMIR作为通用机器中间表示的核心属性并未改变，转换生成的绝大多数GMIR指令仍保持架构无关性，这种设计虽保障了跨架构复用性，但这也必然导致一个核心问题：部分GMIR指令可能超出目标架构的硬件能力范围，成为非法指令，即有部分GMIR指令会存在目标架构不支持的情况。

\par

非法GMIR指令的产生源于架构能力的固有差异，最典型的场景便是数据位宽不匹配。例如，针对16位字长的嵌入式架构，其硬件指令集仅支持16位或32位运算，若IRTranslator因LLVM IR中原有的64位数据运算生成了64位的G\_ADD指令，该指令便会因超出硬件处理能力而成为非法指令。类似地，部分架构不支持向量运算或特定类型的内存访问，对应的GMIR向量指令、特殊寻址模式指令也会被判定为非法。

\par

为解决非法GMIR指令的问题，GlobalISel框架实现了一个合法化Pass，这个Pass是衔接GMIR与目标架构特性的关键枢纽。该Pass的工作原理是：首先加载目标架构的完整指令集描述信息，涵盖其支持的数据类型、运算操作以及寄存器约束等关键元数据，随后以函数为基本单位遍历GMIR代码，将其中所有非法指令逐一替换为语义等价的合法GMIR指令序列，从而使生成的指令组合能够完全适配目标架构的硬件能力。


% 2.3.1 指令合法化方法
\subsection{指令合法化方法}
合法化过程以函数为基本单位，采用RPOT算法自函数入口开始依次扫描所有基本块，该遍历顺序能够保证父基本块中的指令优先于子基本块被处理，从而有效避免由控制流分支依赖引发的转换冲突。在进入单个基本块之后，指令按照自顶向下的顺序逐条处理，对每一条GMIR指令进行合法性检查，一旦发现非法指令，立即触发相应的转换逻辑。待当前基本块内所有指令均完成合法化后，再继续处理下一个基本块，直至整个函数范围内的GMIR指令全部完成合法化。指令合法化的处理过程实际上包含了以下两个关键子问题的处理，二者共同构成了指令合法化的完整技术链路：

\begin{enumerate}
	\item
	非法指令识别：通过查询目标架构提供的LegalizerInfo接口来进行判断。一方面需要判断校验指令操作码与数据类型的组合是否支持，如G\_ADD指令是否支持64位数据。另一方面需要检查指令的操作数约束是否符合架构的要求。例如，针对ARM架构的LegalizerInfo会明确标记G\_FADD（浮点加法）仅支持32位和64位，若GMIR中出现16位浮点加法指令，则会被Pass直接判定为非法。此外，部分架构对指令的隐含约束也会纳入识别逻辑，用于确保识别结果的精准性。
	
	\item
	非法指令转换：当检测到非法指令时，需要通过指令重构来生成一组语义不变且实现架构兼容合法指令序列。由于非法指令产生原因不同，转换策略通常可分为两类。针对数据位宽不匹配的情形，采用拆分与重组相结合的方法，例如将64位的G\_ADD运算拆解为两个32位G\_ADD指令，并通过进位标志的传递实现语义等价的计算。对于目标架构不支持的操作类型，如在缺乏硬件除法单元的体系结构上遇到G\_SDIV指令，则需要通过算法模拟的方式加以替代。除此之外，在整个转换过程中还必须同步完成虚拟寄存器类型的调整以及指令间依赖关系的维护，从而确保重构后的指令序列在数据流和执行效果上与原始指令保持一致。
	
\end{enumerate}

在以上两个子问题得到解决后，合法化Pass就能实现GMIR从通用到架构适配的关键转换。这为后续的寄存器组选择以及目标指令生成等流程提供了合法且可靠的输入基础。


% 2.3.2 指令合法化实现
\subsection{指令合法化实现}
合法化阶段的主要任务是完成非法指令的识别与非法指令的转化。在具体实现上，首先需要明确目标架构所支持的LLT类型集合，该集合不仅包括各类数据类型，还包括地址类型与内存访问相关的类型信息。上述类型集合构成了指令合法性判定的基础边界，用以描述目标架构在位宽支持、对齐约束以及寻址能力等方面的硬件限制。

\par

在明确架构支持的LLT类型集合之后，构建一组用于对GMIR指令进行合法性判定与处理策略选择的合法化规则集。规则集的核心载体是LegalityQuery对象，对象采用结构化封装的方式，将合法性判定所需的关键信息统一组织为标准数据结构。具体包括指令操作码、各操作数索引对应的LLT类型、MachineMemOperand中描述的内存访问字节大小，以及针对内存类指令的原子性与顺序约束等信息。DSP架构的部分合法化规则集如代码块\ref{lst:legal_rules}所示。

\lstset{language=c++}
\begin{lstlisting}[language=C++, caption={DSP架构部分合法化规则集}, label={lst:legal_rules}]
	DSPLegalizerInfo::DSPLegalizerInfo(const DSPSubtarget &ST)
			: STI(ST), XLen(STI.getXLen()), SXLen(LLT::scalar(XLen)) { 
		const LLT S1 = LLT::scalar(1);
		const LLT S8 = LLT::scalar(8);
		const LLT S16 = LLT::scalar(16);
		const LLT S32 = LLT::scalar(32);
		const LLT S64 = LLT::scalar(64);
		const LLT P0 = LLT::pointer(0, 32);
		const LLT SDoubleXLen = LLT::scalar(2 * XLen);
		......
		auto &ShiftActions = getActionDefinitionsBuilder({G_ASHR,G_LSHR,G_SHL});
		if (ST.is64Bit())
		ShiftActions.customFor({{S32, S32}});
		ShiftActions.legalFor({{S32, S32}, {S32, SXLen}, {SXLen, SXLen}})
		.widenScalarToNextPow2(0)
		.clampScalar(1, S32, SXLen)
		.clampScalar(0, S32, SXLen)
		.minScalarSameAs(1, 0);
		......
	\end{lstlisting}

这种设计在工程上具有明显的优势。一方面，其他编译Pass可直接基于LegalityQuery对象查询指令合法性，而无需重复解析指令内部结构，从而有效地降低实现复杂度。另一方面，合法性判定过程不依赖于实际指令实例的构造，这样做的好处是能够避免额外的对象创建与析构开销，在提升编译效率的同时，能支撑更为复杂和精细的合法性判断逻辑。

\par

合法化规则集的生成与执行遵循统一的标准流程。通过调用getActionDefinitionsBuilder接口，可为指定操作码构建专属的合法化规则集。当输入多个操作码时，该接口会自动将其绑定至同一规则集中，适用于操作语义相近、合法化策略一致的指令类型。规则集中的各条规则按照自上而下的优先级顺序依次匹配，当某条指令成功匹配并完成合法性判定后，其后续处理立即终止，下一条指令将重新从规则集起始位置开始匹配，从而保证每条指令都能获得唯一且确定的合法化结果。

\par

对于一些合法化逻辑复杂的指令，框架提供的标准化的规则集往往不足以无法完成目标架构适配，因此需要实现自定义合法化函数legalizeCustom来承载专有的合法化逻辑。与此同时，对于架构强相关的内建函数，还需要额外实现legalizeIntrinsic的处理入口，以完成对应内建函数的合法化。以G\_VASTART指令为例，该指令用于在可变参数函数中标记可变参数的起始位置，由于规则集不足以完成DSP架构的适配，于是需要通过legalizeCustom实现该指令的合法化，将通用的G\_VASTART语义映射为DSP架构可执行的内存存储序列，并显式体现与栈帧布局相关的约束关系。实现代码如代码块\ref{lst:va_legal_func}所示。

\lstset{language=c++}
\begin{lstlisting}[language=C++, caption={VAStart合法化实现}, label={lst:va_legal_func}]
	bool DSPLegalizerInfo::legalizeVAStart(MachineInstr &MI,
			MachineIRBuilder &MIRBuilder) const {
		assert(MI.getOpcode() == TargetOpcode::G_VASTART);
		MachineFunction *MF = MI.getParent()->getParent();
		DSPMachineFunctionInfo *FuncInfo = MF->getInfo<DSPMachineFunctionInfo>();
		int FI = FuncInfo->getVarArgsFrameIndex();
		LLT AddrTy = MIRBuilder.getMRI()->getType(MI.getOperand(0).getReg());
		auto FINAddr = MIRBuilder.buildFrameIndex(AddrTy, FI);
		assert(MI.hasOneMemOperand());
		MIRBuilder.buildStore(FINAddr, MI.getOperand(0).getReg(), *MI.memoperands()[0]);
		MI.eraseFromParent();
		return true;
	}
\end{lstlisting}


%*********************************************************************
% 2.4 寄存器组选择
%*********************************************************************
\section{寄存器组选择}
虽然指令合法化阶段引入了目标架构的指令信息，并将GMIR生成阶段生成的GMIR转换为符合目标架构约束的合法GMIR，但此时的GMIR指令仍然没有具体的寄存器分配信息。指令里的虚拟寄存器操作数仅携带用于表示其类型和位数大小的数据类型描述。因此，全局指令选择模块需要进一步为GMIR中的虚拟寄存器确定其可映射的寄存器组类型，即完成寄存器组选择过程。

\par

寄存器组选择是全局指令选择模块的第三个基本Pass，它会利用目标架构的寄存器信息，自顶向下的为合法化后的GMIR指令中的虚拟寄存器操作数分配合适的寄存器组类型，并且它还可以利用GMIR指令之间的关系选取一个较优的寄存器组类型。这也是不能直接在GMIR生成处理中为直接分配寄存器类型的原因之一：在GMIR生成阶段生成指令时，LLVM IR还没有全部转换成GMIR，无法利用指令之间的关系进行寄存器类型择优。


% 2.4.1 寄存器组
\subsection{寄存器组}
在GlobalISel框架中，Register Bank（寄存器组）是面向目标架构的重要抽象组件，其设计目标是在满足硬件指令访问约束的前提下，通过弱约束分组机制管理寄存器组资源，实现寄存器分配灵活性与跨寄存器组数据交互开销的平衡，从而兼顾编译效率与生成代码性能。与传统的Register Class（寄存器类）不同，Register Bank仅关注寄存器的最大数据宽度及支持的操作集合，而不对具体物理编号和精确位宽做强约束，这使得编译器在分配阶段拥有更大的选择空间。

\par

Register Bank的提出源于硬件架构的实际限制。许多嵌入式处理器及异构计算平台将物理寄存器划分为多个相互独立的寄存器文件，不同文件之间的寄存器无法被同一条指令同时访问。若操作数分布在不同寄存器文件中，必须通过额外的数据复制指令完成中转，从而引入不必要的性能开销。寄存器组通过将物理寄存器按文件属性进行逻辑分组，使编译器能够在寄存器分配阶段优先将关联变量分配到同一寄存器组中，从源头减少跨文件数据复制。

\par

在实际架构中，寄存器组的划分通常与运算单元类型相关，例如通用寄存器组（GPR）对应整数运算单元、浮点寄存器组（FPR）对应浮点运算单元。GMIR指令在寄存器组的使用上遵循以下原则：一方面，特定指令必须使用指定寄存器组（如浮点运算只能使用 FPR）；另一方面，部分指令允许在多个寄存器组间灵活分配，其最终选择由后续运算需求决定，从而避免不必要的跨组数据复制。该弱约束设计不仅降低了寄存器分配复杂度，也显著减少了跨寄存器文件的数据搬运开销，尤其适合嵌入式与DSP等资源受限架构。同时，寄存器组的抽象方式具有良好的扩展性，新架构仅需在目标描述中定义寄存器组属性即可完成适配，无需修改编译器核心逻辑。表\ref{tab:reg_type_class}列出了DSP架构下使用的Register Bank与Register Class划分情况。

\begin{table}[htbp]
	\centering
	\caption{DSP架构下寄存器抽象类型与分类}
	\label{tab:reg_type_class}
	
	\renewcommand{\arraystretch}{1.2}
	{\footnotesize
		\begin{tabularx}{\linewidth}{
				>{\raggedright\arraybackslash}X
				>{\raggedright\arraybackslash}X
			}
			\toprule
			\textbf{寄存器抽象层级} & \textbf{具体实例} \\
			\midrule
			Register Bank &
			GPRBRegBank、CRBRegBank、VPRBRegBank \\
			
			Register Class &
			GPR32EVEN、GPR32、GPR64、VTRegs、OBMRegs、VPR4Out、VPR8Out、VPR16Out、VPRSf、VPRHf \\
			\bottomrule
		\end{tabularx}
	}
\end{table}


% 2.4.2 寄存器组选择方法
\subsection{寄存器组选择方法}
寄存器组选择阶段的核心任务是在GMIR指令完成合法化处理后，为指令中所有虚拟寄存器操作数匹配并分配适配的寄存器组，从而确保后续指令选择与物理寄存器分配过程能够满足目标架构的硬件访问约束。在DSP架构下，寄存器组选择模块的整体设计如图\ref{fig:registerbankinfo_class}所示。该模块主要由DSPGenRegisterBankInfo与DSPRegisterBankInfo两部分构成：前者由TableGen根据DSPRegisterBanks.td文件自动生成，负责描述目标架构中可用的寄存器组及其基础属性；后者则作为目标后端的核心实现类，封装了寄存器组选择所需的全部信息与决策逻辑，包括指令到寄存器组的映射规则、操作数属性以及不同映射方案之间的代价评估。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{pics/registerbankinfo_class.png}
	\caption{DSP 架构下寄存器组选择模块结构图}
	\label{fig:registerbankinfo_class}
\end{figure}


% 2.4.3 寄存器组选择实现
\subsection{寄存器组选择实现}
基于上一节对寄存器组选择核心机制的设计分析，本节将从寄存器组定义、映射结构定义及映射逻辑实现三个核心维度展开，详细阐述面向DSP架构的编译器后端中，寄存器组选择模块的具体实现方案。


\subsubsection{1.寄存器组的定义}
DSP处理器内部包含了多种不同类型的寄存器，不同寄存器在位宽、用途及访问方式上存在显著差异。为保证寄存器分配与硬件执行语义的一致性，需要首先对目标架构中可参与寄存器分配的寄存器资源进行建模。表\ref{tab:dsp_register_class}给出了DSP架构中主要寄存器类的数量、位宽及功能特性，为后续寄存器组划分与寄存器组选择策略的设计提供硬件基础。表中列出的仅为DSP架构下部分不透明寄存器类及其功能描述，其中不透明寄存器类是指对编译器后端可见、并参与寄存器分配与调度的寄存器集合；而对开发人员透明的寄存器类（如中断返回地址寄存器、基址寄存器、偏移寄存器及取模寄存器等）由于其使用方式固定，不参与寄存器分配过程，故不在此列出。

\begin{table}[htbp]
	\centering
	\caption{DSP 架构主要寄存器类特性}
	\label{tab:dsp_register_class}
	
	\renewcommand{\arraystretch}{1.2}
	{\footnotesize
		\begin{tabularx}{\linewidth}{
				>{\raggedright\arraybackslash}m{2.5cm}
				>{\centering\arraybackslash}m{1.0cm}
				>{\centering\arraybackslash}m{1.4cm}
				>{\centering\arraybackslash}X
			}
			\toprule
			寄存器类 & 数量 & 宽度 / bit & 功能描述 \\
			\midrule
			通用寄存器（GR） & 32 & 32 & 使用频率最高的寄存器，用于存放标量指令中的运算数据及地址信息，支撑整型运算与内存访问等基础操作 \\
			
			矢量寄存器（VR） & $4 \times 16$ & 640 & 用于存放矢量运算数据，采用四路并行设计，支持 SIMD 模式下多数据元素的并行加载、存储与计算 \\
			
			控制寄存器（CR） & 1 & 32 & 用于保存处理器状态信息，包括进位标志、溢出标志以及比较指令的结果标志等，参与指令执行控制与条件判断 \\
			\bottomrule
		\end{tabularx}
	}
\end{table}

在DSP架构编译器后端的RegisterInfo类中，通用寄存器被划归至CPURegs寄存器类，矢量寄存器被划归至CPUVecRegs寄存器类，控制寄存器被划归至CCR寄存器类。上述寄存器类的划分构成了寄存器组定义的基础，基于该分类体系完成了DSP架构寄存器组的定义如代码块\ref{lst:rb_def}所示。
	
\lstset{language=c++}
\begin{lstlisting}[language=C++, caption={DSP架构寄存器组定义}, label={lst:rb_def}]
def GPRBRegBank : RegisterBank<"GPRB", [GPR32, GPR64]>;
def VPRBRegBank : RegisterBank<"GPRB", [VPR4Out, VPR8Out, VPR16Out]>;
def CRBRegBank  : RegisterBank<"CRB",  [CCR]>;
\end{lstlisting}


\subsubsection{2.映射结构的定义}
寄存器组选择阶段采用三级分层映射结构，其整体架构及层级关联关系如图\ref{fig:mapping}所示。该映射体系自底向上由PartialMapping、ValueMapping和InstructionMapping三个层次逐级构成，用于描述指令操作数到寄存器组的映射关系及其代价评估过程。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{pics/mapping.png}
	\caption{寄存器组分层映射结构图}
	\label{fig:mapping}
\end{figure}

作为三级分层映射结构的最底层原子映射单元，PartialMapping的核心功能是精准描述操作数中某一连续比特区间与特定寄存器组的单向绑定关系，其设计天然支持大整数位宽拆分、向量数据分片映射以及非对齐数据布局等复杂场景，可灵活适配不同指令类型的操作数映射需求，为上层映射结构提供细粒度的硬件约束支撑。以图\ref{fig:mapping}中指令为例，64位整型加法指令G\_ADD的通用操作数可通过一个PartialMapping将$0\sim64$位整体映射至通用寄存器组GPRB；32位整型比较指令G\_ICMP的通用操作数仅需将$0\sim32$位映射至GPRB。

\par

ValueMapping由一个或多个PartialMapping组合而成，用于描述单个操作数到寄存器组的完整映射方案。图中展示了同一类通用操作数可能存在多种ValueMapping方案的情况，不同方案对应不同的映射代价，用于反映寄存器使用效率或潜在的跨寄存器组数据复制开销。以图\ref{fig:mapping}中的64位G\_ADD，其操作数既可以用一个GPR64来映射，又可以用两个GPR32来映射。

\par

InstructionMapping的作用是对一条指令的所有操作数映射进行统一建模，不仅包含每个操作数对应的ValueMapping，还关联了该指令整体映射方案的代价值。以图\ref{fig:mapping}中指令为例，G\_ADD、G\_ICMP以及VADD等指令均可生成各自的InstructionMapping，其总代价由各操作数映射代价综合决定。寄存器组选择阶段将基于这些代价信息，在满足指令硬性约束的前提下选择最优映射方案。

\par

在具体实现中，有Fast和Greedy两种寄存器组分配策略。其中Fast策略仅为指令匹配并分配目标架构预定义的默认可用寄存器组组合，无需枚举所有合法方案，因此实现简单、运行开销低，适用于对编译速度敏感的场景；而Greedy策略则在默认映射方案的基础上，进一步枚举目标架构允许的所有合法寄存器组组合，逐一计算其映射代价，并最终选择代价最低的方案。该策略能够在更大搜索空间内优化寄存器组分配，减少跨寄存器组的数据复制开销，但相应地增加了寄存器组选择阶段的计算成本。

\par

在LLVM的RegisterBankInfo实现中，PartialMapping、ValueMapping等结构通常以静态表的方式定义，用于描述不同位宽、不同操作数类型在目标架构下的寄存器组映射规则。代码\ref{lst:mapping_def}给出了DSP目标架构中PartialMapping与ValueMapping的典型定义方式。

\lstset{language=c++}
\begin{lstlisting}[language=C++, caption={DSP架构下各Mapping定义}, label={lst:mapping_def}]
	PartialMapping PartMappings[] = {
		{0, 32, GPRBRegBank},
		{0, 64, GPRBRegBank},
		{0, 32, CRBRegBank},
		...... };
	
	ValueMapping ValueMappings[] = {
		{nullptr, 0},
		{&PartMappings[PMI_GPRB32], 1},
		{&PartMappings[PMI_GPRB32], 1},
		{&PartMappings[PMI_GPRB32], 1},
		{&PartMappings[PMI_GPRB64], 1},
		{&PartMappings[PMI_GPRB64], 1},
		{&PartMappings[PMI_GPRB64], 1},
		...... };
\end{lstlisting}

通过上述分层映射结构的实现，寄存器组选择阶段完成了从比特级类型映射到全指令级分配决策的逐层抽象。该方法既避免了在早期阶段过早绑定具体物理寄存器，又能够在完整的指令粒度上对不同寄存器组分配方案的代价进行评估，从而为后续的指令选择与寄存器分配阶段提供了明确且优化的寄存器资源使用约束。


\subsubsection{3.映射逻辑的实现}
寄存器组选择的核心实现通过重载RegisterBankInfo类中的相关接口完成，其中最核心的是getInstrMapping与getInstrAlternativeMapping两个函数。前者负责为每条指令生成默认的寄存器组映射方案，后者则用于在默认映射不适用或存在更优分配时，提供备选的寄存器组映射方案，从而支持更灵活、更高效的寄存器资源分配策略。

\begin{algorithm}[htbp]
	\SetAlgoLined
	\linespread{1}\selectfont
	
	\KwIn{MI: Machine Instruction}
	\KwOut{InstructionMapping}
	\caption{Core Logic of getInstrMapping}
	\label{alg:mapping-core}
	
	Opc \gets opcode of MI\;
	
	\If{MI is non-generic or Opc is G\_PHI}{
		Mapping \gets getInstrMappingImpl(MI)\;
		\If{Mapping is valid}{
			\Return Mapping\;
		}
	}
	
	Initialize operand mapping array OpdsMapping\;
	
	\BlankLine
	\ForEach{operand op in MI}{
		\If{op is a register and op.reg is valid}{
			Obtain the low-level type Ty of op.reg\;
			\If{Ty is invalid or bit width of Ty $\le$ 32}{
				Assign op to a 32-bit GPR container\;
			}
			\Else{
				Assign op to a 64-bit GPR container\;
			}
		}
	}
	
	\BlankLine
	\If{Opc consumes a condition value}{
		Override the mapping of the condition operand to the control register bank (CRB)\;
	}
	
	\If{Opc produces a comparison result}{
		Force the result operand to use a 32-bit GPR container\;
	}
	
	\BlankLine
	Construct and return the final InstructionMapping from OpdsMapping\;
\end{algorithm}

getInstrMapping的实现流程如算法\ref{alg:mapping-core}所示。其实现采用以规则驱动为核心的寄存器组映射构建流程。该流程首先以指令操作码为入口，对可直接由TableGen规则覆盖的场景进行快速判定。对于特殊指令，优先尝试使用TableGen自动生成的映射结果；一旦匹配成功，即可直接返回对应的InstructionMapping，从而避免后续不必要的分析与代价评估。

\par

当TableGen映射不可用时，算法进入基于操作数语义的通用映射阶段。此阶段以操作数为粒度，遍历指令中的所有寄存器操作数，并依据其LLT进行映射决策。在完成默认映射后，算法进一步结合指令语义对映射结果进行修正。最终，算法基于上述映射规则构建并返回完整的InstructionMapping。


%*********************************************************************
% 2.5 机器指令选择
%*********************************************************************
\section{机器指令选择}
机器指令选择是GlobalISel框架的第二阶段核心任务，承接第一阶段（GMIR生成、指令合法化、寄存器类型选择）的处理结果，其核心目标是将经过合法化的、附着目标架构信息的通用机器中间表示GMIR，完整转换为目标架构专属的机器中间表示MIR，为后续基于MIR的寄存器分配、指令调度、窥孔优化等后端流程提供合法输入，是衔接通用中间表示与架构专属表示的关键枢纽。

\par

机器指令选择以单个函数为处理粒度，基于树覆盖的指令选择算法，通过将GMIR指令序列构建为AST，再通过树模式匹配映射为目标架构指令序列，确保语义等价性与架构兼容性。目前框架实现了两种树覆盖的方式：一种是基于表驱动的自动状态机进行的自动覆盖方式；另一种是基于固定模式的手动覆盖方式。这两种覆盖方式在每次覆盖的时候都只会产生一种成功匹配的树模式，因此可以直接生成对应的MIR指令序列\cite{PengLLVM2024}。

\par

机器指令选择采用PROT+自底向上处理的执行逻辑，确保指令依赖关系的正确性与处理效率，具体流程如下：首先以单个函数为处理单元，采用RPOT算法从函数底部开始依次扫描所有基本块，该遍历顺序可保障父基本块的指令处理滞后于子基本块，避免因分支依赖导致的未定义指令引用问题；进入单个基本块后，按自底向上的顺序逐行处理每条GMIR指令，处理前先判断当前指令是否已生成对应的MIR指令，若已生成则直接跳过以避免重复处理，若未生成则以该指令为根节点触发自动匹配模块与手动匹配模块的协同匹配流程；匹配成功后由指令生成模块输出对应的MIR指令序列，若匹配失败则直接触发编译报错；最后以基本块为单位迭代执行上述流程，直至整个函数的所有GMIR指令均成功转换为MIR指令或触发报错，完成该函数的机器指令选择任务。


% 2.5.1 匹配状态机
\subsection{匹配状态机}
在LLVM的指令选择体系中，匹配状态机是支撑基于表驱动的树覆盖指令选择的核心组件，匹配状态机本质是一种由TableGen工具自动生成的FSM（Finite State Machine，有限状态机），其核心作用是将GMIR指令构成的AST与目标架构的指令模式进行自动化匹配，从而确定可映射为MIR的合法目标指令模式。

\par

在TableGen的描述文件中，目标架构的指令结构以树模式（Pattern）进行形式化定义。TableGen工具会对所有Pattern进行解析，并提取其关键特征，包括操作码、操作数类型、寄存器组约束以及数据位宽等。这些特征随后被系统化地编码为状态机的状态节点与转移条件。TableGen最终将所有状态节点及其间的转移关系整合，生成完整的状态机实现代码。该状态机覆盖了从初始状态开始，历经若干中间匹配状态，直至到达最终成功匹配状态或失败状态的完整路径。在生成的状态机中，每一个成功匹配状态都唯一对应一条可被选择的目标架构指令模式，从而确保指令匹配过程的确定性与一致性。

\par

在机器指令选择阶段，匹配状态机针对单条GMIR指令的执行流程可概括为以下几个步骤：

\begin{enumerate}
	\item
	指令树构建：以当前待处理的GMIR指令为根节点，递归遍历其操作数、子指令，构建完整的抽象语法树。
	
	\item
	状态机初始化：将状态机置为初始状态，从指令树的叶子节点开始向上遍历。
	
	\item 
	状态转移匹配：遍历过程中，根据当前AST节点的特征触发状态机的转移并进入对应状态；若在某一节点处不存在满足条件的转移路径，则判定该子树匹配失败，状态机回退至最近的分支点并尝试其他可行路径；否则输出对应的目标架构指令树模式。
	
\end{enumerate}

为保证指令匹配结果的确定性，LLVM中的指令匹配状态机采用DFA（Deterministic Finite Automaton，确定性有限状态机）模型进行构建。这个设计确保了对于任一给定的指令树，其在整个匹配过程中遵循唯一确定的状态转移路径，并最终导向唯一对应的成功匹配结果，从机制上避免了多模式冲突问题。

\par

基于DFA构建的指令匹配状态机，其在指令选择阶段的核心优势主要体现在自动化生成与可扩展性两个方面。开发人员无需为每条目标指令手动编写匹配代码，仅需在.td文件中声明相应的指令树模式，TableGen工具即可自动生成完整、正确的状态机实现。这一方式显著减少了为目标架构开发指令选择器所需的实现工作量。

\par

当目标架构需要新增指令支持时，仅需在描述文件中补充对应的树模式定义并重新生成状态机，无需修改编译器核心代码，从而在保持指令选择框架整体稳定性的同时，极大地提升了系统的可维护性与可扩展性。从运行效率角度分析，该状态机采用确定性的状态转移机制，在匹配过程中无需对所有可能的指令模式进行穷举搜索。相比基于手动遍历或回溯试探的传统匹配方法，这种机制能够有效提升指令选择环节的执行效率。


% 2.5.2 机器指令选择方法
\subsection{机器指令选择方法}
从功能划分的角度来看，机器指令选择可划分为三个模块：自动匹配模块、手动匹配模块以及指令生成模块。三者共同完成从GMIR到MIR的语义映射过程。


\subsubsection{1.自动匹配模块}
自动匹配模块的核心机制在于构建一个基于表驱动的自动状态机，通过状态转移的方式，实现GMIR与目标架构指令模式的自动匹配。该设计的主要优势在于能够在不依赖人工干预的情况下，高效适配大多数通用指令的匹配需求，从而显著增强了编译器对于指令集扩展的自适应能力。

\par

这一方法不仅有效减少了为每种指令手动编写、维护匹配逻辑的代码量与开发成本，更重要的是，当目标架构进行指令集扩展或引入新指令时，仅需更新模式定义并重新生成状态机，而无需深度修改编译器核心代码。这种机制在保证代码健壮性的同时，大幅提升了编译器后端的整体可维护性与长期可扩展性。

\par

自动匹配模块的工作流程可进一步划分为两个阶段：
第一阶段发生在编译器构建期，由TableGen工具解析目标架构指令的树模式描述，并将其编码为确定性有限状态机；第二阶段发生在编译期，指令选择器利用已生成的状态机，对单条GMIR指令构建的抽象语法树进行自底向上的遍历，通过状态转移自动判定其可匹配的目标指令模式。


\subsubsection{2.手动匹配模块}
尽管自动匹配模块能够覆盖大多数通用指令的选择需求，但在实际编译器工程实践中，部分目标架构特有的复杂指令的语义或操作数约束难以通过TableGen的树模式进行完整描述。针对这类场景，需要通过自定义C++代码实现精细化的指令匹配逻辑。

\par

手动匹配模块通常以内联的C++代码形式实现，其核心逻辑基于对GMIR的显式条件判断。该模块会逐一检查指令的操作码、操作数类型及寄存器约束等关键属性，以判定其是否符合特定目标架构专属指令的语义与格式要求。一旦匹配条件得到满足，模块将直接生成对应的目标机器指令。

\par

作为自动匹配机制的补充，手动匹配模块专门用于处理那些高度依赖具体架构、或对执行性能及硬件语义有严格要求的复杂指令场景。它通过提供细粒度的匹配控制，有效弥补了纯表驱动方法在形式化表达能力上的局限，确保了编译器能够全面且精确地支持目标指令集的全部特性。


\subsubsection{3.指令生成模块}
指令生成模块处于机器指令选择流程的最终环节，其输入为经过匹配模块（自动或手动）所确定的指令树模式。该模块的核心功能是根据预定义的映射关系，将选定的模式实例化，构造出语义完全等价的机器中间表示（MIR）指令序列。在此过程中，它负责完成具体的操作数绑定、寄存器类别指派以及其他必要的指令属性设置。

\par

通过这一转换流程，GMIR中的平台无关指令，被最终转化为与特定目标硬件架构紧密绑定、形式精确的机器指令表示。这些生成的MIR指令随后便可直接参与后续的寄存器分配、指令调度等低级机器代码优化阶段。


% 2.5.3 机器指令选择实现
\subsection{机器指令选择实现}
机器指令选择阶段以单条GMIR指令为处理粒度，目标是在保证语义等价与约束一致的前提下，将通用中间表示逐条映射为符合DSP目标架构语义与资源约束的机器指令。其整体流程可概括为预处理、特殊指令处理、合法性校验、自动匹配以及手动匹配五个阶段，整体流程如算法\ref{alg:isel-core}所示。这种分段的设计能在保持指令选择流程清晰性的同时，也便于针对不同类别指令引入差异化的处理策略。下面对每个阶段的实现逻辑与设计要点进行详细说明。

\begin{algorithm}[htbp]
	\SetAlgoLined
	\linespread{1}\selectfont
	
	\KwIn{MI: Machine Instruction}
	\KwOut{Boolean: Instruction selection result}
	\caption{Core Logic of Instruction Selector}
	\label{alg:isel-core}
	Initialize context objects for MI (MBB, MF, MRI, MIB)\;
	Execute pre-selection lowering on MI\;
	
	\If{MI is a copy instruction}{
		\Return Process copy instruction selection for MI\;
	}
	Get opcode (Opc) of MI\;
	
	\If{Opc is G\_PHI}{
		Extract target register (DefReg) of PHI\;
		Derive target register class (DefRC) of DefReg\;
		\If{DefRC derivation fails}{
			\Return false\;
		}
		\For{each operand in PHI instruction}{
			\If{Operand cannot be constrained to DefRC}{
				\Return false\;
			}
		}
		Update PHI instruction descriptor\;
		\Return Constrain DefReg to DefRC\;
	}
	
	\If{MI has implicit operands not declared explicitly}{
		\Return false\;
	}
	
	\If{Opc is a condition-related generic instruction}{
		\Return Apply condition-specific selection\;
	}
	\If{table-driven selectImpl succeeds}{\Return true\;}
	
	\If{Opc is a special-type generic instruction}{
		\Return Apply special-type instruction selection\;
	}
	\Return false\;
\end{algorithm}


\subsubsection{1.预处理}
为满足DSP目标架构的指令语义，在进入指令选择阶段前，需对部分通用指令执行前置Lowering，将其转换为更贴近底层硬件的等价形式。一个典型的场景是指针运算的处理：由于DSP架构没有专用的指针运算指令，指针通常以整型寄存器保存并参与运算，因此编译器需要将携带指针语义的通用指令转换为语义等价的整型运算指令，并同步更新结果寄存器的LLT，以确保后续的指令匹配、操作数约束检查等环节能够基于统一的、与硬件相符的类型系统进行。


\subsubsection{2.特殊指令处理}
对于语义或结构特殊、难以通过树模式描述的指令，需要在自动匹配之前进行单独处理，主要包括以下几类。

\begin{itemize}
	\item
	PHI指令用于描述控制流汇合处的SSA值合并，属于编译器内部语义，不对应具体硬件指令，其处理重点在于保证定义寄存器与各输入操作数满足一致的寄存器约束，以确保后续寄存器分配的合法性。

	\item
	COPY指令仅承担数据搬运语义，不包含可匹配的运算结构，且可能涉及虚拟寄存器与物理寄存器之间或跨寄存器资源的数据复制，通常无法通过通用树模式完成映射，因此需要采用专门的选择逻辑。

	\item 
	依赖控制寄存器条件位的指令，如BRCOND、ICMP以及FCMP等，需在TableGen驱动的通用匹配流程之前进行提前处理。通过在指令选择阶段直接识别并生成符合目标架构条件码语义的指令序列，可以避免条件值经由普通数据路径再映射至控制寄存器所带来的冗余指令与数据搬移开销。
	
\end{itemize}


\subsubsection{3.合法性校验}
在进入模式匹配前，对指令结构进行必要的合法性检查。例如，通用指令不应携带未显式声明的隐式操作数；若指令形态异常，直接返回失败以避免产生不一致的选择结果，并便于定位后端实现问题。


\subsubsection{4.自动匹配}
对通过前述阶段筛选的通用指令，调用selectImpl执行基于TableGen的树覆盖匹配。该路径覆盖面广、维护成本低，能够将绝大多数通用算术、逻辑、访存等指令自动映射为目标指令模式，是指令选择的主要实现方式。

\par

为兼容SelectionDAGISel，GlobalISel对通用算术与逻辑指令直接复用既有指令模式，而对依赖SDNode的架构专属信息则重新建模，并通过GINodeEquiv显式建立GMIR操作码与ISD操作码的等价关系，实现指令模式的复用。代码块\ref{lst:add_mapping}展示了加法指令的复用。

\lstset{language=c++}
\begin{lstlisting}[language=C++, caption={加法指令的复用}, label={lst:add_mapping}]
	Class GINodeEquiv<Instruction i, SDNode node> {
		Instruction I = i;
		SDNode Node = node;
	}
	
	def : GINodeEquiv<G_ADD, add>;
\end{lstlisting}


\subsubsection{5.手动匹配}
当指令无法被自动匹配覆盖时采用手动匹配。手动匹配通常以专用选择函数的形式存在，对操作数、立即数约束及目标指令序列进行精确构造。例如，针对寄存器内符号扩展的G\_SEXT\_INREG，可通过检查扩展位宽并构造等价的目标指令序列完成选择，同时对新生成指令施加寄存器约束，保证与后续流程兼容。

\par

手动匹配机制在处理因芯片型号差异导致的指令集异构问题时发挥着关键作用。以UMULH（无符号高半乘法）为例，其实现路径因硬件支持度不同而存在显著差异：对于原生支持该指令的芯片型号，可以直接通过TableGen的Pattern将GMIR操作映射为硬件指令；而对于不支持UMULH的型号，则需要在手动路径中将其展开为等价指令序列。

\par

这种设计确保了条件值的生成、传递与消费过程始终被约束在一条最小且确定的指令通路内。这不仅简化了指令选择的逻辑复杂度，减少了指令序列中不必要的数据复制操作，同时也有助于降低寄存器分配的压力与整体执行延迟。对于分支密集、条件判断频繁的程序代码而言，该优化能够显著提升最终生成代码的执行效率。


%*********************************************************************
% 2.6 本章小结
%*********************************************************************
\section{本章小结}
本章详细阐述了GlobalISel在DSP架构上的设计方法与具体实现。首先通过对现有指令选择方案的对比分析，指出传统SelectionDAGISel在流程复杂度和维护成本方面的局限，以及FastISel在代码质量与指令覆盖能力上的不足的问题，在此基础上提出将GlobalISel应用到DSP架构上的技术方案。

\par

本章随后根据GlobalISel的核心执行流程，依次介绍了其在DSP后端中的具体实现方法：在GMIR生成阶段，通过定制ValueHandler适配DSP的ABI与数据类型约束；在合法化阶段，结合LegalizerInfo规则集与Custom处理机制确保指令语义落入硬件能力范围；在寄存器组选择阶段，针对多寄存器文件架构构建映射与代价模型；在机器指令选择阶段，采用TableGen自动匹配与手动匹配相结合的策略完成指令映射。
